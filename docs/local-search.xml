<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>review-types</title>
    <link href="/2022/03/11/review-types/"/>
    <url>/2022/03/11/review-types/</url>
    
    <content type="html"><![CDATA[<h1 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> TEST &#123;<br>    a?: <span class="hljs-built_in">string</span> <span class="hljs-comment">// 字符</span><br>    b?: <span class="hljs-built_in">number</span> <span class="hljs-comment">// 数字</span><br>    c?: <span class="hljs-built_in">boolean</span> <span class="hljs-comment">// 布尔</span><br>    d?: <span class="hljs-built_in">any</span> <span class="hljs-comment">// 任意</span><br>    e?: (<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>)[] <span class="hljs-comment">// 数组</span><br>    f?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> <span class="hljs-comment">// 函数签名</span><br>    g?: &#123;&#125; <span class="hljs-comment">// 对象</span><br>    h?: <span class="hljs-string">&#x27;typescript&#x27;</span> <span class="hljs-comment">// 字符串字面量类型</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><blockquote><p>类型只能被断言为一个更为具体或者更抽象的类型，而不是平级</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> x = <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>;<br><br>Conversion <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;string&#x27;</span> to <span class="hljs-keyword">type</span> <span class="hljs-string">&#x27;number&#x27;</span> may be a mistake because neither <span class="hljs-keyword">type</span> sufficiently overlaps <span class="hljs-keyword">with</span> the other. If <span class="hljs-built_in">this</span> was intentional, convert the expression to <span class="hljs-string">&#x27;unknown&#x27;</span> first.<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">const</span> x = <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-keyword">as</span> &#123;&#125; <span class="hljs-comment">// as any </span><br></code></pre></td></tr></table></figure><blockquote><p>as const 后缀通常用来讲一个通用属性的类型转换为文字类型</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> req = &#123;<span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://www.aad.com&#x27;</span>, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;Get&#x27;</span> &#125;<br><span class="hljs-comment">// req: &#123; url: string, method: string&#125;</span><br><br><span class="hljs-keyword">const</span> req = &#123;<span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://www.aad.com&#x27;</span>, <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;Get&#x27;</span> &#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span><br><br><span class="hljs-comment">// req: &#123; url: &#x27;https://www.aad.com&#x27;, method: &#x27;Get&#x27;&#125; 使用了具体的字面量类型</span><br><br><br></code></pre></td></tr></table></figure><h1 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h1><p>通常当一个值为 undefined | null 时，可能需要去显示排除一下，使用非空断言可以明确排除空值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params">x?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello, &quot;</span> + x.toUpperCase()); <span class="hljs-comment">// x 可能为 string | null | undefined</span><br>&#125;<br><br><span class="hljs-comment">// use !</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params">x?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello, &quot;</span> + x!.toUpperCase()); <span class="hljs-comment">// 手动排除null和undefined， 但是通常规避空值</span><br>&#125;<br><br><span class="hljs-comment">// use ?</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params">x?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello, &quot;</span> + x?.toUpperCase()); <span class="hljs-comment">// 兼容null和undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="类型缩小"><a href="#类型缩小" class="headerlink" title="类型缩小"></a>类型缩小</h1><p>通常当一个类型非常宽泛时，实际去使用时却要去具体到某一个类型，这时就要缩小类型，防止报错</p><blockquote><p>typeof 类型守卫</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params">x?: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">number</span>[]</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>        <span class="hljs-built_in">console</span>.log(x.push(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 利用typeof将 x 收窄</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>真实性 收窄</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params">x?: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(x)&#123;<br>        <span class="hljs-built_in">console</span>.log(x)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>相等性收窄</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">boolean</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(x === y)&#123;<br>        <span class="hljs-built_in">console</span>.log(x.up)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>in 运算符收窄</p></blockquote><blockquote><p>instanceof</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>review-js</title>
    <link href="/2022/03/07/review-js/"/>
    <url>/2022/03/07/review-js/</url>
    
    <content type="html"><![CDATA[<h1 id="数字的最大长度"><a href="#数字的最大长度" class="headerlink" title="数字的最大长度"></a>数字的最大长度</h1><blockquote><p>Javascript Number 类型为IEEE 754 64位双精度浮点格式（64位的二进度数）</p></blockquote><blockquote><p>整数范围为： [-2^53 - 1, 2^53 -1]</p></blockquote><blockquote><p>区分 +0 和 -0 的方式，正是检测 1&#x2F;x 是 Infinity 还是 -Infinity</p></blockquote><blockquote><p>大数相加</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 大数相加</span><br><span class="hljs-comment"> * 数字范围为 [-2^53-1, 2^53-1]</span><br><span class="hljs-comment"> * 将数字转化为字符串相加，避免溢出</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> bigNumberADD = <span class="hljs-function">(<span class="hljs-params">a: number, b: number</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 将数字转化为字符</span><br>    <span class="hljs-keyword">let</span> max = a.toString();<br>    <span class="hljs-keyword">let</span> min = b.toString();<br>    <span class="hljs-keyword">let</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>    <span class="hljs-comment">// 如果a &lt; b ，交换</span><br><br>    <span class="hljs-keyword">if</span> (max.length &lt; min.length) &#123;<br>        <span class="hljs-keyword">let</span> temp = max;<br>        max = min;<br>        min = temp;<br>    &#125;<br><br>    <span class="hljs-comment">// 以最大长度的字符开始遍历</span><br>    <span class="hljs-keyword">while</span> (max.length) &#123;<br>        <span class="hljs-comment">// 取出最后一位字符，并转化为数字</span><br>        <span class="hljs-keyword">let</span> temp1 = +max.slice(-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">let</span> temp2 = +min.slice(-<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 尾数 ,新的数字应该放在最前面</span><br>        sum = (temp1 + temp2 + f) % <span class="hljs-number">10</span> + sum;<br><br>        <span class="hljs-comment">// 这里的取整可能会产生小数，要取整；</span><br>        f = <span class="hljs-built_in">Math</span>.floor((temp1 + temp2) / <span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 修改max，min</span><br>        max = max.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>        min = min.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 处理完时，f还存在，则在前面加一</span><br>    <span class="hljs-keyword">if</span> (f) &#123;<br>        sum = <span class="hljs-number">1</span> + sum<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><p>改良版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>a string</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>b string</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> bigNumberADD = <span class="hljs-function">(<span class="hljs-params">a: string, b: string</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> maxLength = <span class="hljs-built_in">Math</span>.max(a.length, b.length);<br>    <span class="hljs-keyword">let</span> temp1 = a.padStart(maxLength, <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">let</span> temp2 = b.padStart(maxLength, <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">let</span> f = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = maxLength - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        sum = (<span class="hljs-built_in">parseInt</span>(temp1[i]) + <span class="hljs-built_in">parseInt</span>(temp2[i]) + f) % <span class="hljs-number">10</span> + sum;<br>        f = <span class="hljs-built_in">Math</span>.floor((<span class="hljs-built_in">parseInt</span>(temp1[i]) + <span class="hljs-built_in">parseInt</span>(temp2[i]) + f) / <span class="hljs-number">10</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (f) &#123;<br>        sum = <span class="hljs-string">&quot;1&quot;</span> + sum;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="基本类型的装箱"><a href="#基本类型的装箱" class="headerlink" title="基本类型的装箱"></a>基本类型的装箱</h1><p>基本类型在使用时，. 运算符提供了装箱操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;1&#x27;</span>;<br>a.toFixed(); <span class="hljs-comment">// a在被调用前，进行了装箱操作</span><br></code></pre></td></tr></table></figure><h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><blockquote><p>Javascript 是一门面向对象的语言, 它不仅实现了面向对象的基本特征，而且具有高度的动态性（可以在运行时修改对象的属性)  </p></blockquote><blockquote><p>对象的特征：</p></blockquote><pre><code>具有唯一标识，即使完全相同的两个对象，也并非同一个对象具有状态，同一个对象可以处于不同的状态具有行为，行为可以改变状态</code></pre><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>微任务总是在当前队列的尾部添加,宏任务则添添加下一个循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;d&quot;</span>), <span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">var</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;<br>      resolve()<br>  &#125;);<br>  r.then(<span class="hljs-function">() =&gt;</span> &#123; <br>      <span class="hljs-keyword">var</span> begin = <span class="hljs-built_in">Date</span>.now();<br>      <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Date</span>.now() - begin &lt; <span class="hljs-number">1000</span>);<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;c1&quot;</span>) <br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;e&quot;</span>), <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;<br>          resolve()<br>      &#125;).then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;c2&quot;</span>))<br>  &#125;);<br>  <span class="hljs-comment">// c1 -&gt; c2 -&gt; d -&gt; e</span><br></code></pre></td></tr></table></figure><p>实现一个红绿灯</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> light_ele = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.light&#x27;</span>);<br><br> <span class="hljs-keyword">const</span> setLight = <span class="hljs-function">(<span class="hljs-params">color</span>) =&gt;</span> light_ele.style.backgroundColor = color<br><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Light</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-built_in">this</span>.green = <span class="hljs-number">3</span>;<br>     <span class="hljs-built_in">this</span>.yellow = <span class="hljs-number">1</span>;<br>     <span class="hljs-built_in">this</span>.red = <span class="hljs-number">2</span>;<br> &#125;<br><br> Light.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>         setLight(<span class="hljs-string">&#x27;green&#x27;</span>);<br>         <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>             <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;green end&#x27;</span>)<br>             resolve()<br>         &#125;<br>             , <span class="hljs-built_in">this</span>.green * <span class="hljs-number">1000</span>)<br>     &#125;).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>             setLight(<span class="hljs-string">&#x27;yellow&#x27;</span>);<br>             <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;yellow end&#x27;</span>)<br>                 resolve()<br>             &#125;, <span class="hljs-built_in">this</span>.yellow * <span class="hljs-number">1000</span>)<br>         &#125;)<br>     &#125;).then(<span class="hljs-function">() =&gt;</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>             setLight(<span class="hljs-string">&#x27;red&#x27;</span>);<br>             <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;red end&#x27;</span>)<br>                 resolve()<br>             &#125;, <span class="hljs-built_in">this</span>.red * <span class="hljs-number">2000</span>)<br>         &#125;)<br>     &#125;).then(<span class="hljs-function">() =&gt;</span> &#123;<br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;green start&#x27;</span>)<br>         <span class="hljs-built_in">this</span>.run()<br>     &#125;)<br> &#125;<br><br> <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Light()<br> a.run();<br></code></pre></td></tr></table></figure><p>改良版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// html</span><br><br>&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&#x27;light&#x27;</span>&gt;&lt;/div&gt;<br>&lt;style&gt;<br>    .light &#123;<br>        width: 100px;<br>        height: 100px;<br>        border-radius: 50px;<br>        background-color: green;<br>        display: flex;<br>        justify-content: center;<br>        align-items: center;<br>        color: white;<br>    &#125;<br>&lt;/style&gt;<br><br><span class="hljs-keyword">var</span> light_ele = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.light&#x27;</span>);<br><br><span class="hljs-keyword">const</span> setLight = <span class="hljs-function">(<span class="hljs-params">color</span>) =&gt;</span> light_ele.style.backgroundColor = color<br><span class="hljs-keyword">const</span> setInnerText = <span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> light_ele.innerText = text<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params">color, delay</span>) </span>&#123;<br>    setLight(color);<br>    setInnerText(delay)<br>    <span class="hljs-keyword">let</span> timeout = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        setInnerText(--delay)<br>    &#125;, <span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">clearInterval</span>(timeout)<br>        resolve()<br>    &#125;, delay * <span class="hljs-number">1000</span>))<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runLight</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">await</span> run(<span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">await</span> run(<span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">await</span> run(<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-number">2</span>)<br>    &#125;<br>&#125;<br><br>runLight();<br></code></pre></td></tr></table></figure><h1 id="js的词法"><a href="#js的词法" class="headerlink" title="js的词法"></a>js的词法</h1><blockquote><p>NumericLiteral<br>    十进制数、二进制整数、八进制整数和十六进制整数</p></blockquote><blockquote><p>十进制的 Number 可以带小数，小数点前后部分都可以省略，但是不能同时省略<br>    <strong>12.</strong><br>    <strong>.12</strong></p></blockquote><blockquote><p>调用 12.toString()的时候报错 （Uncaught SyntaxError: Invalid or unexpected token）</p></blockquote><blockquote><p>js词法解释器无法区分 . 是小数的词法还是 .运算符，正确的使用方法：12 .toString(); (12).toString()</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>温故而知新</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ts-utils</title>
    <link href="/2021/09/08/ts-utils/"/>
    <url>/2021/09/08/ts-utils/</url>
    
    <content type="html"><![CDATA[<h2 id="From-type-challenges"><a href="#From-type-challenges" class="headerlink" title="From type-challenges"></a>From type-challenges</h2><p>题目基本来自<br><a href="https://github.com/type-challenges/type-challenges/blob/master/README.zh-CN.md">https://github.com/type-challenges/type-challenges/blob/master/README.zh-CN.md</a></p><h3 id="实现-Exclude"><a href="#实现-Exclude" class="headerlink" title="实现 Exclude"></a>实现 Exclude</h3><p>从当前类型中排查掉提供的类型（提供的是类型而不是属性名，和 omit 区分开发）<br>这个提供的类型不一定约束为当前目前类型的子类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> MyExclude&lt;T, U&gt; = T <span class="hljs-keyword">extends</span> U ? <span class="hljs-built_in">never</span> : T<br><br><span class="hljs-keyword">type</span> newType = MyExclude&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt; <span class="hljs-comment">// number</span><br></code></pre></td></tr></table></figure><h3 id="实现-Extract"><a href="#实现-Extract" class="headerlink" title="实现 Extract"></a>实现 Extract</h3><p>与 Exclude 相反，提取一个类型</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">type</span> MyExtract&lt;<span class="hljs-built_in">T</span>, U&gt; = <span class="hljs-built_in">T</span> extends U ? <span class="hljs-built_in">T</span> <span class="hljs-symbol">:</span> never;<br></code></pre></td></tr></table></figure><h3 id="实现-pick"><a href="#实现-pick" class="headerlink" title="实现 pick"></a>实现 pick</h3><p>通过属性名 从一个接口中提取当前属性和它的类型, 该属性名一定是当前接口的属性之一</p><p>属性名可以是一个联合属性</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyPick&lt;T</span>, <span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T&gt;</span> </span>= &#123;<br>    [<span class="hljs-type">P</span> in <span class="hljs-type">K</span>]: <span class="hljs-type">T</span>[<span class="hljs-type">P</span>]<br>&#125;<br><br>interface testData &#123;<br>    age: number<br>    name: string<br>    test: () =&gt; void<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">a</span> </span>= <span class="hljs-type">Pick</span>&lt;testData, <span class="hljs-symbol">&#x27;ag</span>e&#x27; | <span class="hljs-symbol">&#x27;nam</span>e&#x27;&gt; <span class="hljs-comment">// &#123;age: number, name: string&#125;</span><br><br></code></pre></td></tr></table></figure><h3 id="实现-Omit"><a href="#实现-Omit" class="headerlink" title="实现 Omit"></a>实现 Omit</h3><p>通过属性名 从一个接口中删除当前属性和它的类型, 该属性名一定是当前接口的属性之一</p><p>首先借用 Exclude 将不必要的属性名排除掉 ，返回新的属性名集合，再通过 Pick 用该属性名集合获取最新的接口类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyOmit&lt;T</span>, <span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T&gt;</span> </span>= <span class="hljs-type">Pick</span>&lt;<span class="hljs-type">T</span>, <span class="hljs-type">Exclude</span>&lt;keyof <span class="hljs-type">T</span>, <span class="hljs-type">K</span>&gt;&gt;<br><br><br>interface testData &#123;<br>    age: number<br>    name: string<br>    test: () =&gt; void<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">a</span> </span>= <span class="hljs-type">MyOmit</span>&lt;testData, <span class="hljs-symbol">&#x27;ag</span>e&#x27; | <span class="hljs-symbol">&#x27;nam</span>e&#x27;&gt; <span class="hljs-comment">// &#123;test:()=&gt;void&#125;</span><br><br></code></pre></td></tr></table></figure><h3 id="实现-ReadOnly"><a href="#实现-ReadOnly" class="headerlink" title="实现 ReadOnly"></a>实现 ReadOnly</h3><p>将属性全变为 readonly</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">MyReadOnly</span>&lt;<span class="hljs-type">T</span>&gt; = &#123;<br>    readonly [<span class="hljs-type">K</span> in keyof <span class="hljs-type">T</span>]: <span class="hljs-type">T</span>[<span class="hljs-type">K</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-Partial"><a href="#实现-Partial" class="headerlink" title="实现 Partial"></a>实现 Partial</h3><p>将属性全变为可选</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">MyPartial</span>&lt;<span class="hljs-type">T</span>&gt; = &#123;<br>    [<span class="hljs-type">K</span> in keyof <span class="hljs-type">T</span>]?: <span class="hljs-type">T</span>[<span class="hljs-type">K</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-Required"><a href="#实现-Required" class="headerlink" title="实现 Required"></a>实现 Required</h3><p>将属性变为必选</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">MyRequired</span>&lt;<span class="hljs-type">T</span>&gt; = &#123;<br>    [<span class="hljs-type">K</span> in keyof <span class="hljs-type">T</span>]-?: <span class="hljs-type">T</span>[<span class="hljs-type">K</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-Record"><a href="#实现-Record" class="headerlink" title="实现 Record"></a>实现 Record</h3><p>就是遍历第一个参数的每个子类型，然后将值设置为第二参数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Record&lt;K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">any</span>, <span class="hljs-title">T&gt;</span> </span>= &#123;<br>  [<span class="hljs-type">P</span> in <span class="hljs-type">K</span>]: <span class="hljs-type">T</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyRecord&lt;K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">any</span>, <span class="hljs-title">T&gt;</span> </span>= &#123;<br>    [<span class="hljs-type">P</span> in <span class="hljs-type">K</span>]: <span class="hljs-type">T</span><br>  &#125;<br><br>interface a &#123;<br>    age: number,<br>    name: string<br>&#125;<br><br>interface b &#123;<br>    k1: number,<br>    k2: string<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">d</span> </span>= <span class="hljs-type">MyRecord</span>&lt;keyof a,b&gt;<br><br><br></code></pre></td></tr></table></figure><p>keyof any 得到的是 string | number | symbol</p><p>约束 key 的类型为 string | number | symbol 之一</p><h3 id="元祖转对象"><a href="#元祖转对象" class="headerlink" title="元祖转对象"></a>元祖转对象</h3><p>传入一个元组类型，将这个元组类型转换为对象类型，这个对象类型的键&#x2F;值都是从元组中遍历出来</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">TupleToObject&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">readonly</span> <span class="hljs-title">any</span>[]<span class="hljs-title">&gt;</span> </span>= &#123;<br>    [<span class="hljs-type">K</span> in <span class="hljs-type">T</span>[number]]: <span class="hljs-type">K</span><br>&#125;<br><br>const tuple = [<span class="hljs-symbol">&#x27;tesl</span>a&#x27;, <span class="hljs-symbol">&#x27;model</span> <span class="hljs-number">3</span>&#x27;, <span class="hljs-symbol">&#x27;model</span> <span class="hljs-type">X</span>&#x27;, <span class="hljs-symbol">&#x27;model</span> <span class="hljs-type">Y</span>&#x27;] as const<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">a</span> </span>= <span class="hljs-type">TupleToObject</span>&lt;typeof tuple&gt; <span class="hljs-comment">// expected &#123; tesla: &#x27;tesla&#x27;, &#x27;model 3&#x27;: &#x27;model 3&#x27;, &#x27;model X&#x27;: &#x27;model X&#x27;, &#x27;model Y&#x27;: &#x27;model Y&#x27;&#125;</span><br><br><br></code></pre></td></tr></table></figure><h3 id="获取第一个元素"><a href="#获取第一个元素" class="headerlink" title="获取第一个元素"></a>获取第一个元素</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">arr1</span> </span>= [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">arr2</span> </span>= [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">First&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">any</span>[]<span class="hljs-title">&gt;</span> </span>= <span class="hljs-type">T</span>[<span class="hljs-number">0</span>]<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">head1</span> </span>= <span class="hljs-type">First</span>&lt;arr1&gt; <span class="hljs-comment">// expected to be &#x27;a&#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">head2</span> </span>= <span class="hljs-type">First</span>&lt;arr2&gt; <span class="hljs-comment">// expected to be 3</span><br></code></pre></td></tr></table></figure><h3 id="获取元组长度"><a href="#获取元组长度" class="headerlink" title="获取元组长度"></a>获取元组长度</h3><p>创建一个通用的 Length，接受一个 readonly 的数组，返回这个数组的长度</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">tesla</span> </span>= [<span class="hljs-symbol">&#x27;tesl</span>a&#x27;, <span class="hljs-symbol">&#x27;model</span> <span class="hljs-number">3</span>&#x27;, <span class="hljs-symbol">&#x27;model</span> <span class="hljs-type">X</span>&#x27;, <span class="hljs-symbol">&#x27;model</span> <span class="hljs-type">Y</span>&#x27;]<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">spaceX</span> </span>= [<span class="hljs-symbol">&#x27;FALCON</span> <span class="hljs-number">9</span>&#x27;, <span class="hljs-symbol">&#x27;FALCON</span> <span class="hljs-type">HEAVY</span>&#x27;, <span class="hljs-symbol">&#x27;DRAGO</span>N&#x27;, <span class="hljs-symbol">&#x27;STARSHI</span>P&#x27;, <span class="hljs-symbol">&#x27;HUMAN</span> <span class="hljs-type">SPACEFLIGHT</span>&#x27;]<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Length&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">readonly</span> <span class="hljs-title">any</span>[]<span class="hljs-title">&gt;</span> </span>= <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> &#123; length: infer <span class="hljs-type">L</span> &#125; ? <span class="hljs-type">L</span> : never<br><span class="hljs-comment">// type Length&lt;T extends readonly any[]&gt; = T[&#x27;length&#x27;]</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">teslaLength</span> </span>= <span class="hljs-type">Length</span>&lt;tesla&gt; <span class="hljs-comment">// expected 4</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">spaceXLength</span> </span>= <span class="hljs-type">Length</span>&lt;spaceX&gt; <span class="hljs-comment">// expected 5</span><br></code></pre></td></tr></table></figure><h3 id="Awaited"><a href="#Awaited" class="headerlink" title="Awaited"></a>Awaited</h3><p>假如我们有一个 Promise 对象，这个 Promise 对象会返回一个类型。在 TS 中，我们用 Promise 中的 T 来描述这个 Promise 返回的类型。请你实现一个类型，可以获取这个类型。<br>比如：Promise<ExampleType>，请你返回 ExampleType 类型</p><p>利用 infer 解包<br>约束 Promise 时使用 unknown 而非 any，因为它更安全</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">UnPackPromise&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Promise&lt;unknown&gt;&gt;</span> </span>= <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">Promise</span>&lt;infer <span class="hljs-type">R</span>&gt; ? <span class="hljs-type">R</span> :never<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">a</span> </span>= <span class="hljs-type">UnPackPromise</span>&lt;<span class="hljs-type">Promise</span>&lt;string&gt;&gt; <span class="hljs-comment">// string</span><br></code></pre></td></tr></table></figure><h3 id="If"><a href="#If" class="headerlink" title="If"></a>If</h3><p>Implement a utils If which accepts condition C, a truthy return type T, and a falsy return type F. C is expected to be either true or false while T and F can be any type.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">If&lt;C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">boolean</span>,<span class="hljs-title">T</span>,<span class="hljs-title">F&gt;</span> </span>= <span class="hljs-type">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-literal">true</span> ? <span class="hljs-type">T</span> : <span class="hljs-type">F</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">A</span> </span>= <span class="hljs-type">If</span>&lt;<span class="hljs-literal">true</span>, &#x27;a&#x27;, &#x27;b&#x27;&gt;  <span class="hljs-comment">// expected to be &#x27;a&#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">B</span> </span>= <span class="hljs-type">If</span>&lt;<span class="hljs-literal">false</span>, &#x27;a&#x27;, &#x27;b&#x27;&gt; <span class="hljs-comment">// expected to be &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h3><p>Implement the JavaScript Array.concat function in the type system. A type takes the two arguments. The output should be a new array that includes inputs in ltr order</p><p>…展开运算法也可以使用。。。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Concat&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">unknown</span>[],<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">unknown</span>[]<span class="hljs-title">&gt;</span> </span>=  [ ...<span class="hljs-type">T</span>, ...<span class="hljs-type">K</span>]<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Result</span> </span>= <span class="hljs-type">Concat</span>&lt;[<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>]&gt; <span class="hljs-comment">// expected to be [1, 2]</span><br></code></pre></td></tr></table></figure><h3 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h3><p>Implement the JavaScript Array.includes function in the type system. A type takes the two arguments. The output should be a boolean true or false</p><p>keyof A： 取的是 A 中所有公共属性名的联合</p><p>A[keyof A]: A 所有值（key 的类型）组成的联合类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Includes&lt;A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">any</span>[], <span class="hljs-title">T&gt;</span> </span>= <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">A</span>[keyof <span class="hljs-type">A</span>] ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br><br><br><br><span class="hljs-comment">//A[keyof A] =&gt; &#x27;Kars&#x27;|&#x27;Esidisi&#x27;|&#x27;Wamuu&#x27;|&#x27;Santana&#x27;]</span><br><br><span class="hljs-comment">// 判断T子类型是否可与继承 A[keyof A]</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">isPillarMen</span> </span>= <span class="hljs-type">Includes</span>&lt;[<span class="hljs-symbol">&#x27;Kar</span>s&#x27;, <span class="hljs-symbol">&#x27;Esidis</span>i&#x27;, <span class="hljs-symbol">&#x27;Wamu</span>u&#x27;, <span class="hljs-symbol">&#x27;Santan</span>a&#x27;], <span class="hljs-symbol">&#x27;Kar</span>s&#x27;&gt;<br></code></pre></td></tr></table></figure><p>先将数组变为对象结构</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">TupleToObj&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">any</span>[]<span class="hljs-title">&gt;</span> </span>= &#123;<br>    [<span class="hljs-type">K</span> in <span class="hljs-type">T</span>[number]]: <span class="hljs-type">K</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span>  <span class="hljs-title">dd</span> </span>= <span class="hljs-type">TupleToObj</span>&lt;[<span class="hljs-symbol">&#x27;Kar</span>s&#x27;, <span class="hljs-symbol">&#x27;Esidis</span>i&#x27;, <span class="hljs-symbol">&#x27;Wamu</span>u&#x27;, <span class="hljs-symbol">&#x27;Santan</span>a&#x27;]&gt;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">dd</span> </span>= &#123;<br>    <span class="hljs-type">Kars</span>: <span class="hljs-string">&quot;Kars&quot;</span>;<br>    <span class="hljs-type">Esidisi</span>: <span class="hljs-string">&quot;Esidisi&quot;</span>;<br>    <span class="hljs-type">Wamuu</span>: <span class="hljs-string">&quot;Wamuu&quot;</span>;<br>    <span class="hljs-type">Santana</span>: <span class="hljs-string">&quot;Santana&quot;</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>再通过属性调用，获取当前值与属性对比</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">TupleToObj&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">any</span>[]<span class="hljs-title">&gt;</span> </span>= &#123;<br>    [<span class="hljs-type">K</span> in <span class="hljs-type">T</span>[number]]: <span class="hljs-type">K</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyIncludes&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">any</span>[], <span class="hljs-title">K&gt;</span> </span>= <span class="hljs-type">TupleToObj</span>&lt;<span class="hljs-type">T</span>&gt;[<span class="hljs-type">K</span>] <span class="hljs-keyword">extends</span> <span class="hljs-type">K</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">isPillarMen</span> </span>= <span class="hljs-type">MyIncludes</span>&lt;[<span class="hljs-symbol">&#x27;Kar</span>s&#x27;, <span class="hljs-symbol">&#x27;Esidis</span>i&#x27;, <span class="hljs-symbol">&#x27;Wamu</span>u&#x27;, <span class="hljs-symbol">&#x27;Santan</span>a&#x27;], <span class="hljs-symbol">&#x27;Kar</span>s&#x27;&gt;<br><br></code></pre></td></tr></table></figure><h3 id="Push-amp-Unshift"><a href="#Push-amp-Unshift" class="headerlink" title="Push &amp; Unshift"></a>Push &amp; Unshift</h3><p>Implement the generic version of Array.push &amp; Array.unshift</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Push&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">unknown</span>[],<span class="hljs-title">K&gt;</span> </span>= [...<span class="hljs-type">T</span>,<span class="hljs-type">K</span>]<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Unshift&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">unknown</span>[],<span class="hljs-title">K&gt;</span> </span>= [<span class="hljs-type">K</span>,...<span class="hljs-type">T</span>]<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Result</span> </span>= <span class="hljs-type">Push</span>&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], &#x27;<span class="hljs-number">3</span>&#x27;&gt; <span class="hljs-comment">// [1, 2, &#x27;3&#x27;]</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Result</span> </span>= <span class="hljs-type">Unshift</span>&lt;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">0</span>&gt; <span class="hljs-comment">// [0, 1, 2,]</span><br></code></pre></td></tr></table></figure><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="ReturnType-获取函数返回类型"><a href="#ReturnType-获取函数返回类型" class="headerlink" title="ReturnType 获取函数返回类型"></a>ReturnType 获取函数返回类型</h3><p>不使用 ReturnType 实现 TypeScript 的 ReturnType<T> 范型。<br>infer 推断返回类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyReturnType&lt;T</span> <span class="hljs-keyword">extends</span> (<span class="hljs-params">...args: any</span>)<span class="hljs-title">=&gt;any</span> <span class="hljs-title">&gt;</span> </span>= <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> (...args: any)=&gt; infer <span class="hljs-type">R</span> ? <span class="hljs-type">R</span> : never<br><br><br>const fn = (v: boolean) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (v)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>  &#125;<br><br>  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">a</span> </span>= <span class="hljs-type">MyReturnType</span>&lt;typeof fn&gt; <span class="hljs-comment">// 应推导出 &quot;1 | 2&quot;</span><br></code></pre></td></tr></table></figure><h3 id="ReadyOnly2"><a href="#ReadyOnly2" class="headerlink" title="ReadyOnly2"></a>ReadyOnly2</h3><p>实现一个通用 MyReadonly2&lt;T, K&gt;，它带有两种类型的参数 T 和 K。</p><p>K 指定应设置为 Readonly 的 T 的属性集。如果未提供 K，则应使所有属性都变为只读，就像普通的 Readonly<T>一样。</p><p>例如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala">interface <span class="hljs-type">Todo</span> &#123;<br>  title: string<br>  description: string<br>  completed: boolean<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyReadonly2&lt;T</span>,<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span> </span>= keyof <span class="hljs-type">T</span>&gt; = &#123;<br>    readonly [<span class="hljs-type">P</span> in <span class="hljs-type">K</span>]: <span class="hljs-type">T</span>[<span class="hljs-type">P</span>]<br>&#125; &amp; <span class="hljs-type">T</span>  <span class="hljs-comment">// 默认值使用es6的默认值， 使用新的类型和原有类型交叉，key相同时，readonly会增加</span><br><br>const todo: <span class="hljs-type">MyReadonly2</span>&lt;<span class="hljs-type">Todo</span>, <span class="hljs-symbol">&#x27;titl</span>e&#x27; | <span class="hljs-symbol">&#x27;descriptio</span>n&#x27;&gt; = &#123;<br>  title: <span class="hljs-string">&quot;Hey&quot;</span>,<br>  description: <span class="hljs-string">&quot;foobar&quot;</span>,<br>  completed: <span class="hljs-literal">false</span>,<br>&#125;<br><br>todo.title = <span class="hljs-string">&quot;Hello&quot;</span> <span class="hljs-comment">// Error: cannot reassign a readonly property</span><br>todo.description = <span class="hljs-string">&quot;barFoo&quot;</span> <span class="hljs-comment">// Error: cannot reassign a readonly property</span><br>todo.completed = <span class="hljs-literal">true</span> <span class="hljs-comment">// OK</span><br><br></code></pre></td></tr></table></figure><h3 id="深度-Readonly"><a href="#深度-Readonly" class="headerlink" title="深度 Readonly"></a>深度 Readonly</h3><p>实现一个通用的 DeepReadonly<T>，它将对象的每个参数及其子对象递归地设为只读</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">X</span> = &#123;</span><br><span class="hljs-class">  <span class="hljs-title">x</span>: &#123;</span><br><span class="hljs-class">    <span class="hljs-title">a</span>: 1</span><br><span class="hljs-class">    <span class="hljs-title">b</span>: &#x27;<span class="hljs-title">hi&#x27;</span></span><br><span class="hljs-class">  &#125;</span><br>  y: &#x27;hey&#x27;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Expected</span> = &#123;</span><br><span class="hljs-class">  <span class="hljs-title">readonly</span> <span class="hljs-title">x</span>: &#123;</span><br><span class="hljs-class">    <span class="hljs-title">readonly</span> <span class="hljs-title">a</span>: 1</span><br><span class="hljs-class">    <span class="hljs-title">readonly</span> <span class="hljs-title">b</span>: &#x27;<span class="hljs-title">hi&#x27;</span></span><br><span class="hljs-class">  &#125;</span><br>  readonly y: &#x27;hey&#x27;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">DeepReadonly</span>&lt;<span class="hljs-type">T</span>&gt; = &#123;</span><br><span class="hljs-class">  <span class="hljs-title">readonly</span> [<span class="hljs-type">K</span> <span class="hljs-title">in</span> <span class="hljs-title">keyof</span> <span class="hljs-type">T</span>]: <span class="hljs-type">T</span>[<span class="hljs-type">K</span>] <span class="hljs-title">extends</span> <span class="hljs-title">object</span> ?  <span class="hljs-type">DeepReadonly</span>&lt;<span class="hljs-type">T</span>[<span class="hljs-type">K</span>]&gt; : <span class="hljs-type">T</span>[<span class="hljs-type">K</span>]</span><br><span class="hljs-class">&#125; // 对象才能继续深度遍历</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> todo = <span class="hljs-type">DeepReadonly</span>&lt;<span class="hljs-type">X</span>&gt; // should be same as `<span class="hljs-type">Expected</span>`</span><br></code></pre></td></tr></table></figure><h3 id="元组转集合"><a href="#元组转集合" class="headerlink" title="元组转集合"></a>元组转集合</h3><p>实现泛型 TupleToUnion<T>，它覆盖元组的值与其值联合</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Arr</span> </span>= [&#x27;<span class="hljs-number">1</span>&#x27;, &#x27;<span class="hljs-number">2</span>&#x27;, &#x27;<span class="hljs-number">3</span>&#x27;]<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">TupleToUnion&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">unknown</span>[]<span class="hljs-title">&gt;</span> </span>= <span class="hljs-type">T</span>[number]<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">a</span> </span>= <span class="hljs-type">TupleToUnion</span>&lt;<span class="hljs-type">Arr</span>&gt; <span class="hljs-comment">// expected to be &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27;</span><br><br><br></code></pre></td></tr></table></figure><h3 id="可串联构造器"><a href="#可串联构造器" class="headerlink" title="可串联构造器"></a>可串联构造器</h3><p>在 JavaScript 中我们很常会使用可串联（Chainable&#x2F;Pipeline）的函数构造一个对象，但在 TypeScript 中，你能合理的给他附上类型吗？</p><p>在这个挑战中，你可以使用任意你喜欢的方式实现这个类型 - Interface, Type 或 Class 都行。你需要提供两个函数 option(key, value) 和 get()。在 option 中你需要使用提供的 key 和 value 扩展当前的对象类型，通过 get 获取最终结果。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Record 使用key和value构建一个新的类型，最后返回一个全新的函数支持递归</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">Chainable</span>&lt;<span class="hljs-title">Tdict</span>=&#123;&#125;&gt; &#123;<br>  option: &lt;Tkey extends <span class="hljs-built_in">string</span>, Tvalue&gt;(key: Tkey, <span class="hljs-keyword">value</span>: Tvalue) =&gt; Chainable&lt; Tdict &amp;  Record&lt;Tkey, Tvalue&gt;&gt;,<br>  <span class="hljs-keyword">get</span>: ()=&gt; Tdict<br>&#125;<br><br>declare <span class="hljs-keyword">const</span> config: Chainable<br><br><span class="hljs-keyword">const</span> result = config<br>  .option(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">123</span>)<br>  .option(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;type-challenges&#x27;</span>)<br>  .option(<span class="hljs-string">&#x27;bar&#x27;</span>, &#123; <span class="hljs-keyword">value</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span> &#125;)<br>  .<span class="hljs-keyword">get</span>()<br><br><span class="hljs-comment">// 期望 result 的类型是：</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">Result</span> &#123;<br>  foo: number<br>  name: <span class="hljs-built_in">string</span><br>  bar: &#123;<br>    <span class="hljs-keyword">value</span>: <span class="hljs-built_in">string</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="最后一个元素"><a href="#最后一个元素" class="headerlink" title="最后一个元素"></a>最后一个元素</h3><p>实现一个通用 Last<T>，它接受一个数组 T 并返回其最后一个元素的类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">arr1</span> </span>= [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">arr2</span> </span>= [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><br><span class="hljs-comment">// 每次把数组分为当前元素和剩余元素，判断剩余元素个数，即可知道当前元素</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Last&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">unknown</span>[]<span class="hljs-title">&gt;</span> </span>= <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> [infer first, ...(infer <span class="hljs-type">Reset</span>)] ? <span class="hljs-type">Reset</span>[<span class="hljs-symbol">&#x27;lengt</span>h&#x27;] <span class="hljs-keyword">extends</span> <span class="hljs-number">0</span> ? first : <span class="hljs-type">Last</span>&lt;<span class="hljs-type">Reset</span>&gt; : never<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">tail1</span> </span>= <span class="hljs-type">Last</span>&lt;arr1&gt; <span class="hljs-comment">// expected to be &#x27;c&#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">tail2</span> </span>= <span class="hljs-type">Last</span>&lt;arr2&gt; <span class="hljs-comment">// expected to be 1</span><br><br></code></pre></td></tr></table></figure><h3 id="堆栈操作"><a href="#堆栈操作" class="headerlink" title="堆栈操作"></a>堆栈操作</h3><p>实现一个通用 Pop<T>，它接受一个数组 T 并返回一个没有最后一个元素的数组</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">arr1</span> </span>= [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">arr2</span> </span>= [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]<br><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Pop&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">unknown</span>[]<span class="hljs-title">&gt;</span> </span>=  <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> [...(infer <span class="hljs-type">Reset</span>), infer <span class="hljs-type">Last</span>] ? <span class="hljs-type">Reset</span> :never<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Shift&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">unknown</span>[]<span class="hljs-title">&gt;</span> </span>=  <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-type">First</span>, ...(infer <span class="hljs-type">Reset</span>)] ? <span class="hljs-type">Reset</span>:never<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Push&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">unknown</span>[], <span class="hljs-title">K&gt;</span> </span>=  <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> unknown[] ? [...<span class="hljs-type">T</span>, <span class="hljs-type">K</span>] :never<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Unshift&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">unknown</span>[], <span class="hljs-title">K&gt;</span> </span>=  <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> unknown[] ? [<span class="hljs-type">K</span>, ...<span class="hljs-type">T</span>] :never<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">re1</span> </span>= <span class="hljs-type">Pop</span>&lt;arr1&gt; <span class="hljs-comment">// expected to be [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">re2</span> </span>= <span class="hljs-type">Pop</span>&lt;arr2&gt; <span class="hljs-comment">// expected to be [3, 2]</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">re3</span> </span>= <span class="hljs-type">Shift</span>&lt;arr1&gt; <span class="hljs-comment">// expected to be [ &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">re4</span> </span>= <span class="hljs-type">Shift</span>&lt;arr2&gt; <span class="hljs-comment">// expected to be [ 2,1]</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">re5</span> </span>= <span class="hljs-type">Push</span>&lt;arr1, [&#x27;d&#x27;,<span class="hljs-symbol">&#x27;123</span>1&#x27;]&gt; <span class="hljs-comment">// expected to be [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, [&#x27;d&#x27;,&#x27;1231&#x27;]</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">re6</span> </span>= <span class="hljs-type">Push</span>&lt;arr2, <span class="hljs-number">4</span>&gt; <span class="hljs-comment">// expected to be [3,2,1,4]</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">re7</span> </span>= <span class="hljs-type">Unshift</span>&lt;arr1, [&#x27;d&#x27;,<span class="hljs-symbol">&#x27;123</span>1&#x27;]&gt; <span class="hljs-comment">// expected to be [[&#x27;d&#x27;,&#x27;1231&#x27;], &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">re8</span> </span>= <span class="hljs-type">Unshift</span>&lt;arr2, <span class="hljs-number">4</span>&gt; <span class="hljs-comment">// expected to be [4,3,2,1]</span><br><br><br></code></pre></td></tr></table></figure><h3 id="PromiseAll"><a href="#PromiseAll" class="headerlink" title="PromiseAll"></a>PromiseAll</h3><p>键入函数 PromiseAll，它接受 PromiseLike 对象数组，返回值应为 Promise<T>，其中 T 是解析的结果数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// expected to be `Promise&lt;[number, number, string]&gt;`</span><br><br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PromiseAll</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">any</span>[]&gt;(<span class="hljs-params">values: <span class="hljs-keyword">readonly</span> [...T]</span>): <span class="hljs-title">Promise</span>&lt;</span>&#123;<br>    [K <span class="hljs-keyword">in</span> keyof T]: T[K] <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Promise</span>&lt;infer R&gt; ? R : T[K]<br>&#125;&gt;<br><span class="hljs-keyword">const</span> p = PromiseAll([promise1, promise2, promise3] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>)<br></code></pre></td></tr></table></figure><h3 id="Type-Lookup"><a href="#Type-Lookup" class="headerlink" title="Type Lookup"></a>Type Lookup</h3><p>有时，您可能希望根据其属性在并集中查找类型。</p><p>在此挑战中，我们想通过在联合 Cat | Dog 中搜索公共 type 字段来获取相应的类型。换句话说，在以下示例中，我们期望 LookUp&lt;Dog | Cat, ‘dog’&gt;获得 Dog，LookUp&lt;Dog | Cat, ‘cat’&gt;获得 Cat</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala">interface <span class="hljs-type">Cat</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span></span>: <span class="hljs-symbol">&#x27;ca</span>t&#x27;<br>    breeds: <span class="hljs-symbol">&#x27;Abyssinia</span>n&#x27; | <span class="hljs-symbol">&#x27;Shorthai</span>r&#x27; | <span class="hljs-symbol">&#x27;Cur</span>l&#x27; | <span class="hljs-symbol">&#x27;Benga</span>l&#x27;<br>  &#125;<br><br>  interface <span class="hljs-type">Dog</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">type</span></span>: <span class="hljs-symbol">&#x27;do</span>g&#x27;<br>    breeds: <span class="hljs-symbol">&#x27;Houn</span>d&#x27; | <span class="hljs-symbol">&#x27;Brittan</span>y&#x27; | <span class="hljs-symbol">&#x27;Bulldo</span>g&#x27; | <span class="hljs-symbol">&#x27;Boxe</span>r&#x27;<br>    color: <span class="hljs-symbol">&#x27;brow</span>n&#x27; | <span class="hljs-symbol">&#x27;whit</span>e&#x27; | <span class="hljs-symbol">&#x27;blac</span>k&#x27;<br>  &#125;<br><br>  <span class="hljs-comment">// &#123;type: k&#125;表示更宽泛的父类型，而T 表示更具体的子类型</span><br>  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">LookUp&lt;T</span> <span class="hljs-keyword">extends</span> </span>&#123; <span class="hljs-class"><span class="hljs-keyword">type</span></span>: any&#125;, <span class="hljs-type">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">T</span>[<span class="hljs-symbol">&#x27;typ</span>e&#x27;]&gt; = <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> &#123;<span class="hljs-class"><span class="hljs-keyword">type</span></span>: <span class="hljs-type">K</span>&#125; ? <span class="hljs-type">T</span> : never<br><br>  <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyDog</span> </span>= <span class="hljs-type">LookUp</span>&lt;<span class="hljs-type">Cat</span> | <span class="hljs-type">Dog</span>, <span class="hljs-symbol">&#x27;do</span>g&#x27;&gt; <span class="hljs-comment">// expected to be `Dog`</span><br></code></pre></td></tr></table></figure><h3 id="Trim"><a href="#Trim" class="headerlink" title="Trim"></a>Trim</h3><p>Implement TrimLeft<T> which takes an exact string type and returns a new string with the whitespace beginning removed.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br><span class="hljs-comment">// 模板文字类型</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">TrimLeft&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string&gt;</span> </span>= <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> `$&#123;&#x27; &#x27; | &#x27;\n&#x27; | &#x27;\t&#x27;&#125;$&#123;infer <span class="hljs-type">SS</span>&#125;` ? <span class="hljs-type">TrimLeft</span>&lt;<span class="hljs-type">SS</span>&gt; : <span class="hljs-type">T</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">trimed</span> </span>= <span class="hljs-type">TrimLeft</span>&lt;&#x27;  <span class="hljs-type">Hello</span> <span class="hljs-type">World</span>  &#x27;&gt; <span class="hljs-comment">// expected to be &#x27;Hello World  &#x27;</span><br></code></pre></td></tr></table></figure><p>trim</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">// <span class="hljs-built_in">type</span> TrimLeft&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = S <span class="hljs-keyword">extends</span> `$&#123;<span class="hljs-string">&#x27; &#x27;</span> | <span class="hljs-string">&#x27;\n&#x27;</span> | <span class="hljs-string">&#x27;\t&#x27;</span>&#125;$&#123;infer SS&#125;`?TrimLeft&lt;SS&gt;:S<br>// <span class="hljs-built_in">type</span> TrimRight&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = S <span class="hljs-keyword">extends</span> `$&#123;infer SS&#125;$&#123;<span class="hljs-string">&#x27; &#x27;</span> | <span class="hljs-string">&#x27;\n&#x27;</span> | <span class="hljs-string">&#x27;\t&#x27;</span>&#125;`?TrimRight&lt;SS&gt;:S<br>// <span class="hljs-built_in">type</span> Trim&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = TrimLeft&lt;TrimRight&lt;S&gt;&gt;<br><br><span class="hljs-built_in">type</span> Trim&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = T <span class="hljs-keyword">extends</span> `$&#123;infer SS&#125;$&#123;<span class="hljs-string">&#x27; &#x27;</span> | <span class="hljs-string">&#x27;\n&#x27;</span> | <span class="hljs-string">&#x27;\t&#x27;</span>&#125;` | `$&#123;<span class="hljs-string">&#x27; &#x27;</span> | <span class="hljs-string">&#x27;\n&#x27;</span> | <span class="hljs-string">&#x27;\t&#x27;</span>&#125;$&#123;infer SS&#125;` ? Trim&lt;SS&gt; : T<br><br><span class="hljs-built_in">type</span> trimed = Trim&lt;<span class="hljs-string">&#x27;  Hello World  &#x27;</span>&gt; // expected to be <span class="hljs-string">&#x27;Hello World&#x27;</span><br><br></code></pre></td></tr></table></figure><h3 id="Capitalize"><a href="#Capitalize" class="headerlink" title="Capitalize"></a>Capitalize</h3><p>Implement Capitalize<T> which converts the first letter of a string to uppercase and leave the rest as-is.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 还是利用模板文字类型, T的类型更具体，而`$&#123;infer R&#125;$&#123;infer F&#125;`是一个抽象类型作为父类型</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyCapitalize&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string&gt;</span> </span>= <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> `$&#123;infer <span class="hljs-type">R</span>&#125;$&#123;infer <span class="hljs-type">F</span>&#125;` ?  `$&#123;<span class="hljs-type">Uppercase</span>&lt;<span class="hljs-type">R</span>&gt;&#125;$&#123;<span class="hljs-type">F</span>&#125;` :<span class="hljs-type">T</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">capitalized</span> </span>= <span class="hljs-type">MyCapitalize</span>&lt;<span class="hljs-symbol">&#x27;hello</span> world&#x27;&gt; <span class="hljs-comment">// expected to be &#x27;Hello world&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h3><p>Implement Replace&lt;S, From, To&gt; which replace the string From with To once in the given string S</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Replace&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string</span>, <span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string</span>, <span class="hljs-title">P</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string&gt;</span> </span>= <span class="hljs-type">K</span> <span class="hljs-keyword">extends</span> &#x27;&#x27;? <span class="hljs-type">T</span> : <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> `$&#123;infer <span class="hljs-type">F</span>&#125;$&#123;<span class="hljs-type">K</span>&#125;$&#123;infer <span class="hljs-type">L</span>&#125;` ? `$&#123;<span class="hljs-type">F</span>&#125;$&#123;<span class="hljs-type">P</span>&#125;$&#123;<span class="hljs-type">L</span>&#125;` : <span class="hljs-type">K</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">replaced</span> </span>= <span class="hljs-type">Replace</span>&lt;<span class="hljs-symbol">&#x27;types</span> are fun!&#x27;, <span class="hljs-symbol">&#x27;fu</span>n&#x27;, <span class="hljs-symbol">&#x27;awesom</span>e&#x27;&gt; <span class="hljs-comment">// expected to be &#x27;types are awesome!&#x27;</span><br><br></code></pre></td></tr></table></figure><h3 id="ReplaceAll"><a href="#ReplaceAll" class="headerlink" title="ReplaceAll"></a>ReplaceAll</h3><p>Implement ReplaceAll&lt;S, From, To&gt; which replace the all the substring From with To in the given string S</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br><br><span class="hljs-comment">//  对任意值，均可表示为`$&#123;infer F&#125;$&#123;infer T&#125;$&#123;infer L&#125;`, 然后对推测值递归处理</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">ReplaceAll&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string</span>, <span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string</span>, <span class="hljs-title">U</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string&gt;</span> </span>= <span class="hljs-type">K</span> <span class="hljs-keyword">extends</span> &#x27;&#x27; ? <span class="hljs-type">T</span> : <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> `$&#123;infer <span class="hljs-type">F</span>&#125;$&#123;infer <span class="hljs-type">K</span>&#125;$&#123;infer <span class="hljs-type">L</span>&#125;` ? `$&#123;<span class="hljs-type">F</span>&#125;$&#123;<span class="hljs-type">U</span>&#125;$&#123;<span class="hljs-type">ReplaceAll</span>&lt;<span class="hljs-type">L</span>, <span class="hljs-type">K</span>, <span class="hljs-type">U</span>&gt;&#125;` : <span class="hljs-type">T</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">replaced</span> </span>= <span class="hljs-type">ReplaceAll</span>&lt;<span class="hljs-symbol">&#x27;t</span> y p e s&#x27;, &#x27; &#x27;, &#x27;&#x27;&gt; <span class="hljs-comment">// expected to be &#x27;types&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="追加参数"><a href="#追加参数" class="headerlink" title="追加参数"></a>追加参数</h3><p>实现一个范型 AppendArgument&lt;Fn, A&gt;，对于给定的函数类型 Fn，以及一个任意类型 A，返回一个新的函数 G。G 拥有 Fn 的所有参数并在末尾追加类型为 A 的参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> Fn = <span class="hljs-function">(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><br><br><span class="hljs-comment">// 对参数的参数和返回值都可以使用 infer 推断</span><br><span class="hljs-keyword">type</span> AppendArgument&lt;T <span class="hljs-keyword">extends</span> (...args: <span class="hljs-built_in">any</span>) =&gt; <span class="hljs-built_in">any</span>, K&gt; = T <span class="hljs-keyword">extends</span> (...args: infer P) =&gt; infer R ? <span class="hljs-function">(<span class="hljs-params">...args: [...P, K]</span>) =&gt;</span> R : <span class="hljs-built_in">never</span><br><br><span class="hljs-keyword">type</span> Result = AppendArgument&lt;Fn, <span class="hljs-built_in">boolean</span>&gt;<br><span class="hljs-comment">// 期望是 (a: number, b: string, x: boolean) =&gt; number</span><br><br></code></pre></td></tr></table></figure><h3 id="Length-of-String"><a href="#Length-of-String" class="headerlink" title="Length of String"></a>Length of String</h3><p>Compute the length of a string literal, which behaves like String#length.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br><span class="hljs-comment">// 字符串先转数组，再取数组的length</span><br><span class="hljs-comment">// 字符转数组，使用infer 分割， 递归</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">StringToArray&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string&gt;</span> </span>= <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> `$&#123;infer <span class="hljs-type">F</span>&#125;$&#123;infer <span class="hljs-type">R</span>&#125;` ? [<span class="hljs-type">F</span>, ...<span class="hljs-type">StringToArray</span>&lt;<span class="hljs-type">R</span>&gt;] : []<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">StringLength&lt;S</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string&gt;</span> </span>= <span class="hljs-type">StringToArray</span>&lt;<span class="hljs-type">S</span>&gt;[<span class="hljs-symbol">&#x27;lengt</span>h&#x27;]<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">a</span> </span>= <span class="hljs-type">StringLength</span>&lt;<span class="hljs-symbol">&#x27;12313</span> qawqe&#x27;&gt;  <span class="hljs-comment">// 11</span><br><br></code></pre></td></tr></table></figure><h3 id="Flatten"><a href="#Flatten" class="headerlink" title="Flatten"></a>Flatten</h3><p>In this challenge, you would need to write a type that takes an array and emitted the flatten array type.</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><br>type Flatten&lt;T&gt; = T extends <span class="hljs-comment">[]</span> ? <span class="hljs-comment">[]</span> : T extends <span class="hljs-comment">[infer F, ...(infer R)]</span> ? <span class="hljs-comment">[...Flatten&lt;F&gt;, ...Flatten&lt;R&gt;]</span> : <span class="hljs-comment">[T]</span><br><br>type flatten = Flatten&lt;<span class="hljs-comment">[1, 2, <span class="hljs-comment">[3, 4]</span>, <span class="hljs-comment">[<span class="hljs-comment">[<span class="hljs-comment">[5]</span>]</span>]</span>]</span>&gt; // <span class="hljs-comment">[1, 2, 3, 4, 5]</span><br><br></code></pre></td></tr></table></figure><h3 id="AppendObject"><a href="#AppendObject" class="headerlink" title="AppendObject"></a>AppendObject</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Test</span> </span>= &#123; id: &#x27;<span class="hljs-number">1</span>&#x27; &#125;<br><br><span class="hljs-comment">// 合并交叉类型的对象</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">CombineObject&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Object&gt;</span> </span>= &#123;<br>    [<span class="hljs-type">K</span> in keyof <span class="hljs-type">T</span>]: <span class="hljs-type">T</span>[<span class="hljs-type">K</span>]<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">AppendToObject&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">object</span>, <span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string</span>, <span class="hljs-title">P&gt;</span> </span>= <span class="hljs-type">CombineObject</span>&lt;<span class="hljs-type">T</span> &amp; &#123; [<span class="hljs-type">U</span> in <span class="hljs-type">K</span>]: <span class="hljs-type">P</span> &#125;&gt;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Result</span> </span>= <span class="hljs-type">AppendToObject</span>&lt;<span class="hljs-type">Test</span>, <span class="hljs-symbol">&#x27;valu</span>e&#x27;, <span class="hljs-number">4</span>&gt; <span class="hljs-comment">// expected to be &#123; id: &#x27;1&#x27;, value: 4 &#125;</span><br><br></code></pre></td></tr></table></figure><h3 id="Absolute"><a href="#Absolute" class="headerlink" title="Absolute"></a>Absolute</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Test</span> </span>= <span class="hljs-number">-100</span>;<br><br><span class="hljs-comment">// 最后都是string</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Absolute&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string</span> <span class="hljs-title">|</span> <span class="hljs-title">number</span> <span class="hljs-title">|</span> <span class="hljs-title">bigint&gt;</span> </span>= `$&#123;<span class="hljs-type">T</span>&#125;` <span class="hljs-keyword">extends</span> `$&#123;&#x27;-&#x27;&#125;$&#123;infer <span class="hljs-type">R</span>&#125;` ? <span class="hljs-type">R</span> : `$&#123;<span class="hljs-type">T</span>&#125;`<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Result</span> </span>= <span class="hljs-type">Absolute</span>&lt;<span class="hljs-type">Test</span>&gt;; <span class="hljs-comment">// expected to be &quot;100&quot;</span><br><br></code></pre></td></tr></table></figure><h3 id="String-to-union"><a href="#String-to-union" class="headerlink" title="String to union"></a>String to union</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Test</span> </span>= <span class="hljs-symbol">&#x27;12</span>3&#x27;;<br><span class="hljs-comment">//  拆分字符串并递归，终止条件为&quot;&quot;</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">StringToUnion&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string&gt;</span> </span>= <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-string">&quot;&quot;</span> ? never : <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> `$&#123;infer <span class="hljs-type">F</span>&#125;$&#123;infer <span class="hljs-type">L</span>&#125;` ? (<span class="hljs-type">F</span> | <span class="hljs-type">StringToUnion</span>&lt;<span class="hljs-type">L</span>&gt;) : <span class="hljs-type">T</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Result</span> </span>= <span class="hljs-type">StringToUnion</span>&lt;<span class="hljs-type">Test</span>&gt;; <span class="hljs-comment">// expected to be &quot;1&quot; | &quot;2&quot; | &quot;3&quot;</span><br><br></code></pre></td></tr></table></figure><h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Foo</span> </span>= &#123;<br>    a: number;<br>    b: string;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Bar</span> </span>= &#123;<br>    b: number;<br>    c: boolean;<br>&#125;;<br><span class="hljs-comment">// 交叉类型，如果是对象的话，key取的是并集，value取的才是交集</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Merge&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">object</span>, <span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">object&gt;</span> </span>= &#123;<br>    [<span class="hljs-type">P</span> in keyof (<span class="hljs-type">T</span> &amp; <span class="hljs-type">K</span>)]: <span class="hljs-type">P</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-type">K</span> ? <span class="hljs-type">K</span>[<span class="hljs-type">P</span>] : <span class="hljs-type">P</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-type">T</span> ? <span class="hljs-type">T</span>[<span class="hljs-type">P</span>] : never<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">a</span> </span>= <span class="hljs-type">Merge</span>&lt;<span class="hljs-type">Foo</span>, <span class="hljs-type">Bar</span>&gt;<br><br></code></pre></td></tr></table></figure><h3 id="CamelCase"><a href="#CamelCase" class="headerlink" title="CamelCase"></a>CamelCase</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elm"><br>//  <span class="hljs-type">Capitalize</span>&lt;<span class="hljs-type">Right</span>&gt; extends <span class="hljs-type">Right</span> 判断是否为-<br><br><span class="hljs-keyword">type</span> <span class="hljs-type">CamelCase</span>&lt;<span class="hljs-type">T</span> extends string&gt; = <span class="hljs-type">T</span> extends `$&#123;infer <span class="hljs-type">Left</span>&#125;-$&#123;infer <span class="hljs-type">Right</span>&#125;` ? <span class="hljs-type">Capitalize</span>&lt;<span class="hljs-type">Right</span>&gt; extends <span class="hljs-type">Right</span> ? `$&#123;<span class="hljs-type">Left</span>&#125;-$&#123;<span class="hljs-type">CamelCase</span>&lt;<span class="hljs-type">Capitalize</span>&lt;<span class="hljs-type">Right</span>&gt;&gt;&#125;` : `$&#123;<span class="hljs-type">Left</span>&#125;$&#123;<span class="hljs-type">CamelCase</span>&lt;<span class="hljs-type">Capitalize</span>&lt;<span class="hljs-type">Right</span>&gt;&gt;&#125;` : <span class="hljs-type">T</span><br><br><span class="hljs-keyword">type</span> a = <span class="hljs-type">CamelCase</span>&lt;&#x27;foo-bar-baz-a&#x27;&gt;<br></code></pre></td></tr></table></figure><h3 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h3><p>Get an Object that is the difference between O &amp; O1</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dts">type Foo = &#123;<br><span class="hljs-symbol">    name:</span> string<br><span class="hljs-symbol">    age:</span> string<br>  &#125;<br>  type Bar = &#123;<br><span class="hljs-symbol">    name:</span> string<br><span class="hljs-symbol">    age:</span> string<br><span class="hljs-symbol">    gender:</span> number<br>  &#125;<br><br>  <span class="hljs-comment">//  使用交叉类型获得交叉集合</span><br>  type Diff<span class="hljs-params">&lt;T, K&gt;</span> = Pick<span class="hljs-params">&lt;T &amp; K, Exclude&lt;keyof T, keyof K&gt;</span> | Exclude<span class="hljs-params">&lt;keyof K, keyof T&gt;</span>&gt;<br><br>  type a = Diff<span class="hljs-params">&lt;Foo, Bar&gt;</span><br></code></pre></td></tr></table></figure><h3 id="AnyOf"><a href="#AnyOf" class="headerlink" title="AnyOf"></a>AnyOf</h3><p>Implement Python liked any function in the type system. A type takes the Array and returns true if any element of the Array is true. If the Array is empty, return false.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><br><span class="hljs-comment">// 所有假值得联合类型</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">FalseUnion</span> </span>= <span class="hljs-literal">false</span> | &#x27;&#x27; | <span class="hljs-number">0</span> | <span class="hljs-type">Record</span>&lt;string| number, never&gt; |[]<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">AnyOf&lt;T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">any</span>[]<span class="hljs-title">&gt;</span> </span>= <span class="hljs-type">T</span> <span class="hljs-keyword">extends</span> [infer <span class="hljs-type">F</span>, ...(infer <span class="hljs-type">Reset</span>)] ? <span class="hljs-type">F</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">FalseUnion</span>? <span class="hljs-type">AnyOf</span>&lt;<span class="hljs-type">Reset</span>&gt;: <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Sample1</span> </span>= <span class="hljs-type">AnyOf</span>&lt;[<span class="hljs-number">1</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>, [], &#123;&#125;]&gt;; <span class="hljs-comment">// expected to be true.</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Sample2</span> </span>= <span class="hljs-type">AnyOf</span>&lt;[]&gt;; <span class="hljs-comment">// expected to be false.</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ts-types</title>
    <link href="/2021/08/09/ts-types/"/>
    <url>/2021/08/09/ts-types/</url>
    
    <content type="html"><![CDATA[<h3 id="索引类型-index-types"><a href="#索引类型-index-types" class="headerlink" title="索引类型 index types"></a>索引类型 index types</h3><p>索引类型查询: keyof T</p><p>keyof T 的结果为T上已知的公共属性名的联合</p><p>下面 keyof T 的结果为 ‘name’ | ‘age’</p><p>索引访问操作符: T[K]</p><p>先决条件 K extends keyof T</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pluck</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">o: T, names: K[]</span>): <span class="hljs-title">T</span>[<span class="hljs-title">K</span>][] </span>&#123;<br>    <span class="hljs-keyword">return</span> names.map(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> o[n])<br>&#125;<br><span class="hljs-keyword">interface</span> Person &#123;<br>    name: <span class="hljs-built_in">string</span>;<br>    age: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">let</span> person: Person = &#123;<br>    name: <span class="hljs-string">&#x27;Jarid&#x27;</span>,<br>    age: <span class="hljs-number">3</span><br>&#125;;<br><br><br><span class="hljs-keyword">let</span> strings: <span class="hljs-built_in">string</span>[] = pluck(person, [<span class="hljs-string">&#x27;name&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h3><p>为类型推断提供分支选项</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-keyword">type</span> diff&lt;T, U&gt; =<br>    T <span class="hljs-keyword">extends</span> U ? <span class="hljs-built_in">never</span> : T<br><br><br><span class="hljs-keyword">type</span> test = diff&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&gt; <span class="hljs-comment">// string | number</span><br></code></pre></td></tr></table></figure><p>ts 官方库</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">/**<br> * Exclude from <span class="hljs-built_in">T</span> those types that are assignable to U<br> */<br><span class="hljs-built_in">type</span> Exclude&lt;<span class="hljs-built_in">T</span>, U&gt; = <span class="hljs-built_in">T</span> extends U ? never <span class="hljs-symbol">:</span> <span class="hljs-built_in">T</span>;<br><br>/**<br> * Extract from <span class="hljs-built_in">T</span> those types that are assignable to U<br> */<br><span class="hljs-built_in">type</span> Extract&lt;<span class="hljs-built_in">T</span>, U&gt; = <span class="hljs-built_in">T</span> extends U ? <span class="hljs-built_in">T</span> <span class="hljs-symbol">:</span> never;<br></code></pre></td></tr></table></figure><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>映射类型建立在索引签名的语法之上，用于声明尚未提前声明的属性类型：</p><p>映射类型是一种泛型类型，它使用PropertyKeys的联合（通常通过 a keyof创建）来迭代键以创建类型：</p><p>type OptionsFlags<Type> &#x3D; {<br>  [Property in keyof Type]: boolean;<br>};</p><p>映射修饰符<br>有两个额外的修饰符可以在映射期间应用：readonly和?分别影响可变性和可选性。</p><p>您可以通过添加-或前缀来删除或添加这些修饰符+。如果不添加前缀，则+为默认值</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs elm">/**<br> * <span class="hljs-type">Make</span> all properties <span class="hljs-keyword">in</span> <span class="hljs-type">T</span> readonly<br> */<br><span class="hljs-keyword">type</span> <span class="hljs-type">Readonly</span>&lt;<span class="hljs-type">T</span>&gt; = &#123;<br>    readonly [<span class="hljs-type">P</span> in keyof <span class="hljs-type">T</span>]: <span class="hljs-type">T</span>[<span class="hljs-type">P</span>];<br>&#125;;<br><br>/**<br> * <span class="hljs-type">Make</span> all properties <span class="hljs-keyword">in</span> <span class="hljs-type">T</span> optional<br> */<br><span class="hljs-keyword">type</span> <span class="hljs-type">Partial</span>&lt;<span class="hljs-type">T</span>&gt; = &#123;<br>    [<span class="hljs-type">P</span> in keyof <span class="hljs-type">T</span>]?: <span class="hljs-type">T</span>[<span class="hljs-type">P</span>];<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><p>键重映射</p><p>在 TypeScript 4.1 及更高版本中，您可以使用映射类型中的as子句重新映射映射类型中的键：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">MappedTypeWithNewProperties</span>&lt;<span class="hljs-type">Type</span>&gt; = &#123;<br>    [<span class="hljs-type">Properties</span> in keyof <span class="hljs-type">Type</span> as <span class="hljs-type">NewKeyType</span>]: <span class="hljs-type">Type</span>[<span class="hljs-type">Properties</span>]<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-type">RemoveKindField</span>&lt;<span class="hljs-type">Type</span>&gt; = &#123;<br>    [<span class="hljs-type">Property</span> in keyof <span class="hljs-type">Type</span> as <span class="hljs-type">Exclude</span>&lt;<span class="hljs-type">Property</span>, &quot;kind&quot;&gt;]: <span class="hljs-type">Type</span>[<span class="hljs-type">Property</span>]<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ts-alias</title>
    <link href="/2021/07/27/ts-alias/"/>
    <url>/2021/07/27/ts-alias/</url>
    
    <content type="html"><![CDATA[<h3 id="使用create-react-app-创建带有ts的模板"><a href="#使用create-react-app-创建带有ts的模板" class="headerlink" title="使用create-react-app 创建带有ts的模板"></a>使用create-react-app 创建带有ts的模板</h3><p>yarn create react-app my-app –template typescript</p><h3 id="覆盖ts配置并配置别名"><a href="#覆盖ts配置并配置别名" class="headerlink" title="覆盖ts配置并配置别名"></a>覆盖ts配置并配置别名</h3><p>cra创建的模板每次启动时会自动覆盖一部分配置，所以需要自己通过extends将需要的部分重写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// tsconfig.json</span><br>  <span class="hljs-string">&quot;extends&quot;</span>: <span class="hljs-string">&quot;./tsconfig.base.json&quot;</span>,<br><br><span class="hljs-comment">// tsconfig.base.json</span><br>&#123;<br>    <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;src&quot;</span>,<br>        <span class="hljs-string">&quot;paths&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;@/*&quot;</span>: [<span class="hljs-string">&quot;*&quot;</span>]<br>        &#125;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="覆盖cra配置"><a href="#覆盖cra配置" class="headerlink" title="覆盖cra配置"></a>覆盖cra配置</h3><p>此时，ts编译时的别名已经生效，但是打包阶段webpack的路径依然会报错。<br>1.通过安装 customize-cra<br>This project relies on react-app-rewired. You’ll need to install that in order for customize-cra to work.</p><p><a href="https://github.com/arackaf/customize-cra">customize-cra</a><br><a href="https://github.com/timarney/react-app-rewired/blob/master/README_zh.md">react-app-rewired</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">yarn add customize-cra react-app-rewired --dev<br></code></pre></td></tr></table></figure><p>2.替换脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">-   <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;react-scripts start&quot;</span>,<br>+   <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;react-app-rewired start&quot;</span>,<br>-   <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;react-scripts build&quot;</span>,<br>+   <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;react-app-rewired build&quot;</span>,<br>-   <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;react-scripts test --env=jsdom&quot;</span>,<br>+   <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;react-app-rewired test --env=jsdom&quot;</span>,<br></code></pre></td></tr></table></figure><p>3.添加需要覆盖的配置，重写webpack打包时的别名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; override, addWebpackAlias, addDecoratorsLegacy &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;customize-cra&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-built_in">module</span>.exports = override(<br>  addWebpackAlias(&#123;<br>    <span class="hljs-string">&quot;@&quot;</span>: path.resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)<br>  &#125;),<br>  addDecoratorsLegacy(), <br>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>workflows</title>
    <link href="/2021/07/27/workflows/"/>
    <url>/2021/07/27/workflows/</url>
    
    <content type="html"><![CDATA[<h3 id="工具的用法随着版本会发生变化"><a href="#工具的用法随着版本会发生变化" class="headerlink" title="工具的用法随着版本会发生变化"></a>工具的用法随着版本会发生变化</h3><p>安装最新版本时，实际用法请参考官方文档</p><h3 id="prettier-格式化代码"><a href="#prettier-格式化代码" class="headerlink" title="prettier-格式化代码"></a>prettier-格式化代码</h3><p>1.安装 <a href="https://prettier.io/docs/en/install.html">prettier</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">yarn add --dev --exact prettier<br></code></pre></td></tr></table></figure><p>2.vscode 安装插件 Prettier - Code formatter</p><p>3.打开 vscode 选择默认格式化工具,同时配置 format on save</p><p>4.通过 <a href="https://github.com/okonet/lint-staged#configuration">lint-staged</a> 添加 pre-commit Hooks</p><p>需要提前安装依赖<br>This command will install and configure husky and lint-staged depending on the code quality tools from your project’s package.json dependencies, so please make sure you install (npm install –save-dev) and configure all code quality tools like Prettier and ESLint prior to that</p><p>然后直接运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javacript">npx mrm@2 lint-staged<br></code></pre></td></tr></table></figure><h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>安装 <a href="https://eslint.org/docs/user-guide/getting-started">eslint</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">yarn add eslint<br>npx eslint --init<br></code></pre></td></tr></table></figure><p>eslint-config-prettier 解决冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">extends</span>: [<br>  <span class="hljs-string">&#x27;plugin:react/recommended&#x27;</span>,<br>  <span class="hljs-string">&#x27;airbnb&#x27;</span>,<br>  <span class="hljs-string">&#x27;prettier&#x27;</span>,<br>],<br></code></pre></td></tr></table></figure><h3 id="commitizen"><a href="#commitizen" class="headerlink" title="commitizen"></a>commitizen</h3><p><a href="https://github.com/commitizen/cz-cli">commit</a> 生成管理工具</p><p>安装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install -g commitizen<br></code></pre></td></tr></table></figure><p>使用不同的适配器</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">commitizen</span> <span class="hljs-comment">init</span> <span class="hljs-comment">cz</span><span class="hljs-literal">-</span><span class="hljs-comment">conventional</span><span class="hljs-literal">-</span><span class="hljs-comment">changelog</span> --<span class="hljs-comment">yarn</span> --<span class="hljs-comment">dev</span> --<span class="hljs-comment">exact</span><br></code></pre></td></tr></table></figure><p>使用 git-cz&#x2F;cz&#x2F;npx cz 完成 commit 提交</p><h3 id="commit-lint"><a href="#commit-lint" class="headerlink" title="commit-lint"></a>commit-lint</h3><p>约束 commit 生成格式<br>安装 <a href="https://github.com/conventional-changelog/commitlint/#what-is-commitlint">commit-lint</a></p><p>同时配置 commit-style 为 <a href="https://github.com/conventional-changelog/commitlint/tree/master/@commitlint/config-angular">config-angular</a></p><h3 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h3><p>安装 <a href="https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog-cli#readme">conventional-changelog-cli</a></p><p>运行命令生成 changlog</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">conventional-changelog -p angular -i CHANGELOG.md -s<br></code></pre></td></tr></table></figure><h3 id="Standard-Version"><a href="#Standard-Version" class="headerlink" title="Standard Version"></a>Standard Version</h3><p>发布版本时，<br>自动生成 changlog<br>提升 verion<br>生成新的 tag</p><p>安装 <a href="https://github.com/conventional-changelog/standard-version">Standard Version</a></p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs q">npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> standard-version<br><br>&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;release&quot;</span>: <span class="hljs-string">&quot;standard-version&quot;</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-fiber</title>
    <link href="/2021/07/13/react-fiber/"/>
    <url>/2021/07/13/react-fiber/</url>
    
    <content type="html"><![CDATA[<h3 id="Stack-Reconciler面临的问题"><a href="#Stack-Reconciler面临的问题" class="headerlink" title="Stack Reconciler面临的问题"></a>Stack Reconciler面临的问题</h3><p>开始渲染时，Stack Reconciler 是一个同步的递归过程。该架构下的diff算法是一个树的深度优先遍历，树复杂的情况下会占用过多的主线程时间</p><h3 id="fiber架构"><a href="#fiber架构" class="headerlink" title="fiber架构"></a>fiber架构</h3><p>增量渲染，将渲染任务分片，使任务可中断、可回复与优先级<br>16之前，react更新流程：<br>Reconciler -&gt; render</p><p>16之后<br>Scheduler -&gt; Reconciler -&gt; render</p><h3 id="fiber架构下的render"><a href="#fiber架构下的render" class="headerlink" title="fiber架构下的render"></a>fiber架构下的render</h3><p>render调用栈的三个阶段：<br>1.初始化<br>2.render阶段<br>3.commit阶段</p><h3 id="三个启动模式"><a href="#三个启动模式" class="headerlink" title="三个启动模式"></a>三个启动模式</h3><p>legacy模式：原本的同步渲染机制<br>blocking模式：目前正在实验中，作为迁移到 concurrent 模式的第一个步骤<br>concurrent模式：异步渲染模式</p><p>fiber架构同时兼容了异步渲染和同步渲染</p><p>文档资料参考：<a href="https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#why-so-many-modes">https://zh-hans.reactjs.org/docs/concurrent-mode-adoption.html#why-so-many-modes</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-setState</title>
    <link href="/2021/07/12/react-setState/"/>
    <url>/2021/07/12/react-setState/</url>
    
    <content type="html"><![CDATA[<h3 id="setState-调用之后触发的生命周期"><a href="#setState-调用之后触发的生命周期" class="headerlink" title="setState 调用之后触发的生命周期"></a>setState 调用之后触发的生命周期</h3><p>setState -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</p><h3 id="异步更新的动机"><a href="#异步更新的动机" class="headerlink" title="异步更新的动机"></a>异步更新的动机</h3><p>批量更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./styles.css&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;<br><br>  state = &#123;<br><br>    count: <span class="hljs-number">0</span><br><br>  &#125;<br><br>  increment = <span class="hljs-function">() =&gt;</span> &#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;increment setState前的count&#x27;</span>, <span class="hljs-built_in">this</span>.state.count)<br><br>    <span class="hljs-built_in">this</span>.setState(&#123;<br><br>      count: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span><br><br>    &#125;);<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;increment setState后的count&#x27;</span>, <span class="hljs-built_in">this</span>.state.count)<br><br>  &#125;<br><br>  triple = <span class="hljs-function">() =&gt;</span> &#123;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;triple setState前的count&#x27;</span>, <span class="hljs-built_in">this</span>.state.count)<br><br>    <span class="hljs-built_in">this</span>.setState(&#123;<br><br>      count: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span><br><br>    &#125;);<br><br>    <span class="hljs-built_in">this</span>.setState(&#123;<br><br>      count: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span><br><br>    &#125;);<br><br>    <span class="hljs-built_in">this</span>.setState(&#123;<br><br>      count: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span><br><br>    &#125;);<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;triple setState后的count&#x27;</span>, <span class="hljs-built_in">this</span>.state.count)<br><br>  &#125;<br><br>  reduce = <span class="hljs-function">() =&gt;</span> &#123;<br><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;reduce setState前的count&#x27;</span>, <span class="hljs-built_in">this</span>.state.count)<br><br>      <span class="hljs-built_in">this</span>.setState(&#123;<br><br>        count: <span class="hljs-built_in">this</span>.state.count - <span class="hljs-number">1</span><br><br>      &#125;);<br><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;reduce setState后的count&#x27;</span>, <span class="hljs-built_in">this</span>.state.count)<br><br>    &#125;,<span class="hljs-number">0</span>);<br><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>    <span class="hljs-keyword">return</span> &lt;div&gt;<br><br>      &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.increment&#125;&gt;点我增加&lt;/button&gt;<br><br>      &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.triple&#125;&gt;点我增加三倍&lt;/button&gt;<br><br>      &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.reduce&#125;&gt;点我减少&lt;/button&gt;<br><br>    &lt;/div&gt;<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果每一次调用setState都直接触发完整生命周期，re-render将会带来性能问题.那么此时就需要异步更新，利用Event-Loop,等时机成熟，再把“攒起来”的 state 结果做合并，最后只针对最新的 state 值走一次更新流程。同步任务不结束就一直放入，最后只针对最新的 state 值走一次更新流程<br>，这就是批量更新。</p><h3 id="同步现象"><a href="#同步现象" class="headerlink" title="同步现象"></a>同步现象</h3><p>本质上是由 React 事务机制和批量更新机制的工作方式来决定<br>setState调用时会判断内部 batchingStrategy.isBatchingUpdates标识状态来决定是立即更新，还是先放入更新队列，等待批量更新</p><p>在生命周期等位置需要开启批量更新，但是setTimeout是异步的，它执行时这个isBatchingUpdates标记已经放开了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>increment = <span class="hljs-function">() =&gt;</span> &#123;<br><br>  <span class="hljs-comment">// 进来先锁上</span><br><br>  isBatchingUpdates = <span class="hljs-literal">true</span><br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;increment setState前的count&#x27;</span>, <span class="hljs-built_in">this</span>.state.count)<br><br>  <span class="hljs-built_in">this</span>.setState(&#123;<br><br>    count: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span><br><br>  &#125;);<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;increment setState后的count&#x27;</span>, <span class="hljs-built_in">this</span>.state.count)<br><br>  <span class="hljs-comment">// 执行完函数再放开</span><br><br>  isBatchingUpdates = <span class="hljs-literal">false</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-reconciliation</title>
    <link href="/2021/07/12/react-reconciliation/"/>
    <url>/2021/07/12/react-reconciliation/</url>
    
    <content type="html"><![CDATA[<h3 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h3><p>概念：使用js对象对真实dom的一种描述<br>原理：<br>    js操作-&gt;真实dom渲染 这一层中间加了一层<br>    js操作-&gt;虚拟dom diff-&gt;真实dom渲染<br>优化：<br>    差量更新：当 DOM 操作（渲染更新）比较频繁时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个“补丁集”，最后只把“补丁”打在需要更新的那部分真实 DOM 上，实现精准的“差量更新”<br>    批量更新：使用batch函数，batch 的作用是缓冲每次生成的补丁集，<br>    它会把收集到的多个补丁集暂存到队列中，再将最终的结果交给渲染函数，最终实现集中化的 DOM 批量更新</p><h3 id="价值"><a href="#价值" class="headerlink" title="价值"></a>价值</h3><p>1.提高了研发体验和研发效率，为数据驱动视图这一思想提供了高度可用的载体，使得前端开发能够基于函数式 UI 的编程方式实现高效的声明式编程<br>2.跨平台的问题：虚拟 DOM 是对真实渲染内容的一层抽象。类似于多端抽象出来的中间层</p><h3 id="调和的概念"><a href="#调和的概念" class="headerlink" title="调和的概念"></a>调和的概念</h3><p>通过如 ReactDOM 等类库使虚拟 DOM 与“真实的” DOM 同步，这一过程叫作协调（调和）。<br>diff是调和过程中最突出的一部分</p><h3 id="Diff要点"><a href="#Diff要点" class="headerlink" title="Diff要点"></a>Diff要点</h3><p>1.Diff算法性能突破的关键点在于分层对比。DOM 节点之间的跨层级操作并不多，同层级操作是主流<br>2.类型一致（key和tagName都相同）的几点才有diff的必要性。若两个组件属于同一个类型，那么它们将拥有相同的 DOM 树形结构<br>3.key 属性的设置，可以帮我们尽可能重用同一层级内的节点。key能解决同一层级下，节点重用问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-hooks</title>
    <link href="/2021/07/08/react-hooks/"/>
    <url>/2021/07/08/react-hooks/</url>
    
    <content type="html"><![CDATA[<h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromProps</span>(<span class="hljs-params">props, state</span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;sub&#x27;</span>, props);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>      &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">window</span>.bus.emit(<span class="hljs-string">&#x27;msg&#x27;</span>, <span class="hljs-string">&#x27;dadada&#x27;</span>);<br>    &#125;  <br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.emit&#125;&gt;子组件&lt;/button&gt;<br>                &#123;<span class="hljs-built_in">this</span>.props.time&#125;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="何谓函数组件-x2F-无状态组件（Function-Component-x2F-Stateless-Component）"><a href="#何谓函数组件-x2F-无状态组件（Function-Component-x2F-Stateless-Component）" class="headerlink" title="何谓函数组件&#x2F;无状态组件（Function Component&#x2F;Stateless Component）"></a>何谓函数组件&#x2F;无状态组件（Function Component&#x2F;Stateless Component）</h3><p>函数组件顾名思义，就是以函数的形态存在的 React 组件.早期并没有 React-Hooks 的加持，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123;useState, useEffect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Increase</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> change = <span class="hljs-function">()=&gt;</span>&#123;<br>        setCount(count++)<br>    &#125;<br>    useEffect(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;effect&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div onClick=&#123;change&#125;&gt;<br>            adad  test hooks<br>            &#123;count&#125;<br>        &lt;/div&gt;<br>    )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Increase<br></code></pre></td></tr></table></figure><h3 id="Why-React-Hooks"><a href="#Why-React-Hooks" class="headerlink" title="Why React-Hooks"></a>Why React-Hooks</h3><p>1.告别难以理解的class<br>this的指向较复杂，经常不符合预期。生命周期需要学习成本</p><p>2.解决业务逻辑难以拆分的问题<br>业务逻辑通常被打散到各个生命周期，难以维护<br>而hooks可以帮助实现业务逻辑的聚合，避免复杂的组件和冗杂的代码</p><p>3.使状态逻辑复用更加简单<br>过去我们复用状态逻辑，靠的是 HOC（高阶组件）和 Render Props 这些组件设计模式</p><p>4.函数组件更加契合 React 框架的设计理念</p><h3 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h3><p>函数组件会捕获 render 内部的状态，这是两类组件最大的不同</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>底层通过链表来更新内容<br>hooks 的渲染是通过“依次遍历”来定位每个 hooks 内容的。如果前后两次读到的链表在顺序上出现差异，那么渲染的结果自然是不可控的<br>原则：<br>只在 React 函数中调用 Hook；</p><p>不要在循环、条件或嵌套函数中调用 Hook</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React-components</title>
    <link href="/2021/07/07/react-components/"/>
    <url>/2021/07/07/react-components/</url>
    
    <content type="html"><![CDATA[<h3 id="组件渲染核心"><a href="#组件渲染核心" class="headerlink" title="组件渲染核心"></a>组件渲染核心</h3><p>数据驱动视图 react的视图是由数据驱动的</p><h3 id="基于-props-的单向数据流"><a href="#基于-props-的单向数据流" class="headerlink" title="基于 props 的单向数据流"></a>基于 props 的单向数据流</h3><p>指的就是当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更低的组件。 比如在父-子组件这种嵌套关系中，只能由父组件传 props 给子组件，而不能反过来。</p><h3 id="组建通信"><a href="#组建通信" class="headerlink" title="组建通信"></a>组建通信</h3><p>使用基于 Props 的单向数据流串联父子、兄弟组件；<br>利用“发布-订阅”模式驱动 React 数据在任意组件间流动。</p><p>父子： 通过props，将父组件的state流向子组件<br>子父： 父组件通过props，将一个绑定了自身上下文的函数传递到子组件，那么子组件在调用该函数时，就可以将想要交给父组件的数据以函数入参的形式给出去，间接改变父组件数据<br>兄弟： 同一个父组件，将兄弟1-&gt;兄弟2的通信转换为 兄弟1-&gt;父组件 父组件-&gt;兄弟2，兄弟1借用父元素函数改变父元素state，然后父元素通过props将state流向兄弟2<br>复杂组件间：通过发布订阅模式，解耦合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EventEmitter</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.callback = &#123;&#125;;<br>&#125;<br><br>EventEmitter.prototype = &#123;<br>    <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">type, callback</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.callback[type])&#123;<br>            <span class="hljs-built_in">this</span>.callback[type] = [];<br>        &#125;<br>        <span class="hljs-built_in">this</span>.callback[type].push(callback);<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">type, data</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.callback[type])&#123;<br>            <span class="hljs-built_in">this</span>.callback[type].forEach(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>                element.call(<span class="hljs-built_in">this</span>, data)<br>            &#125;);<br>        &#125;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">type, cb</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.callback[type])&#123;<br>            <span class="hljs-keyword">const</span> len = <span class="hljs-built_in">this</span>.callback[type].length - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = len; i &gt;=<span class="hljs-number">0</span>; i--)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.callback[type][i] === cb)&#123;<br>                    <span class="hljs-built_in">this</span>.callback[type].splice(i,<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> EventEmitter<br></code></pre></td></tr></table></figure><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>严格遵循单一数据流<br>在 Redux 的整个工作过程中，数据流是严格单向的<br><img src="/images/reducer.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-lifecyles</title>
    <link href="/2021/07/06/react-lifecyles/"/>
    <url>/2021/07/06/react-lifecyles/</url>
    
    <content type="html"><![CDATA[<h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p>mount:<br>consructor<br>static getDerivedStateFromProps()<br>render<br>componentDidMount</p><p>update:<br>static getDerivedStateFromProps()<br>shouldComponentUpdate()<br>render()<br>getSnapshotBeforeUpdate()<br>componentDidUpdate()</p><h3 id="render是react组件生命周期的核心"><a href="#render是react组件生命周期的核心" class="headerlink" title="render是react组件生命周期的核心"></a>render是react组件生命周期的核心</h3><p>虚拟 DOM 自然不必多说，它的生成都要仰仗 render；而组件化概念中所提及的“渲染工作流”，这里指的是从组件数据改变到组件实际更新发生的过程，这个过程的实现同样离不开 render</p><p>规则：<br>render() 方法是 class 组件中唯一必须实现的方法<br>当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回以下类型之一：React元素、数组或者fragment、Portals、字符串或者数值类型、布尔类型或 null</p><h3 id="新的生命周期"><a href="#新的生命周期" class="headerlink" title="新的生命周期"></a>新的生命周期</h3><p>16.3版本及以后增加了 getDerivedStateFromProps生命周期，废弃了componentWillMount<br>1.该生命周期主要用来从props派生state，是一个静态方法，不能调用this，使用生命周期时要保证它的纯洁性<br>2.接收2个参数，props和state，它应返回一个对象来更新 state，如果返回 null 则不更新任何内容，可以对state进行增量更新<br>3.任何因素触发的组件更新流程（包括由 this.setState 和 forceUpdate 触发的更新流程）都会触发 getDerivedStateFromProps；而在 v 16.3 版本时，只有父组件的更新会触发该生命周期</p><h3 id="生命周期废旧立新的原因"><a href="#生命周期废旧立新的原因" class="headerlink" title="生命周期废旧立新的原因"></a>生命周期废旧立新的原因</h3><p>为fiber的异步渲染做准备<br>在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-jsx</title>
    <link href="/2021/07/05/react-jsx/"/>
    <url>/2021/07/05/react-jsx/</url>
    
    <content type="html"><![CDATA[<h3 id="jsx的本质"><a href="#jsx的本质" class="headerlink" title="jsx的本质"></a>jsx的本质</h3><p>| JSX 是 JavaScript 的一种语法扩展，它和模板语言很接近，但是它充分具备 JavaScript 的能力</p><h3 id="jsx-如何编译成js"><a href="#jsx-如何编译成js" class="headerlink" title="jsx 如何编译成js"></a>jsx 如何编译成js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// jsx 语法文件</span><br>&lt;div className=<span class="hljs-string">&#x27;test&#x27;</span>&gt;<br>  &lt;p&gt;<span class="hljs-number">123</span>&lt;/p&gt;  <br>&lt;/div&gt;<br><br><span class="hljs-comment">// babel 转义之后的js文件</span><br>React.createElement(<span class="hljs-string">&quot;div&quot;</span>, &#123;<br>  className: <span class="hljs-string">&quot;test&quot;</span><br>&#125;, React.createElement(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;123&quot;</span>));<br></code></pre></td></tr></table></figure><p>JSX标签都被转化为了React.createElement的调用，JSX 的本质是React.createElement这个 JavaScript 调用的语法糖</p><h3 id="jsx的优点"><a href="#jsx的优点" class="headerlink" title="jsx的优点"></a>jsx的优点</h3><p>jsx精简的语法糖，让我们使用类html标签语法来创建虚拟dom（使用js对象语法描述dom元素），降低了学习成本同时提高了工作效率</p><h3 id="createElement的作用"><a href="#createElement的作用" class="headerlink" title="createElement的作用"></a>createElement的作用</h3><p>开发者通过入参type、config、children调用createElement,创建了一个ReactElement对象，这个对象就是虚拟dom</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//jsx</span><br><br>        <span class="hljs-keyword">const</span> ele = (<br>            &lt;div className=<span class="hljs-string">&quot;test&quot;</span>&gt;<br>                &lt;p&gt;test&lt;/p&gt;    <br>            &lt;/div&gt;<br>        )<br><br><span class="hljs-comment">// 转换过程</span><br><br><span class="hljs-keyword">const</span> ele = React.createElement(<span class="hljs-string">&quot;div&quot;</span>, &#123;<br>  className: <span class="hljs-string">&quot;test&quot;</span><br>&#125;, React.createElement(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;test&quot;</span>));<br><br><br><span class="hljs-comment">// 转换之后的ReactElement对象 ele</span><br>&#123;<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;div&quot;</span>,<br>    <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&quot;ref&quot;</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&quot;props&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;className&quot;</span>: <span class="hljs-string">&quot;test&quot;</span>,<br>        <span class="hljs-string">&quot;children&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;p&quot;</span>,<br>            <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-literal">null</span>,<br>            <span class="hljs-string">&quot;ref&quot;</span>: <span class="hljs-literal">null</span>,<br>            <span class="hljs-string">&quot;props&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;children&quot;</span>: <span class="hljs-string">&quot;test&quot;</span><br>            &#125;,<br>            <span class="hljs-string">&quot;_owner&quot;</span>: <span class="hljs-literal">null</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-string">&quot;_owner&quot;</span>: <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1.JSX 的本质是什么，它和 JS 之间到底是什么关系？</p><p>本质是js中 React.createElement的语法糖，是一种js语法的拓展。最后通过babel编译成真正的js语法。</p><p>2.为什么要用 JSX？不用会有什么后果？</p><p>jsx使用类html的方式构造虚拟dom，降低学习成本，提高效率</p><p>3.JSX 背后的功能模块是什么，这个功能模块都做了哪些事情？<br>React.createElement 、ReactElement<br>通过createElement 将用户参数传入的数据格式化，最后通过ReactElement创建虚拟dom</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ReactElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, key, ref, self, source, owner, props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> element = &#123;<br>    <span class="hljs-comment">// REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement</span><br>    $$typeof: REACT_ELEMENT_TYPE,<br><br>    <span class="hljs-comment">// 内置属性赋值</span><br>    type: type,<br>    key: key,<br>    ref: ref,<br>    props: props,<br><br>    <span class="hljs-comment">// 记录创造该元素的组件</span><br>    _owner: owner,<br>  &#125;;<br><br>  <span class="hljs-comment">// </span><br>  <span class="hljs-keyword">if</span> (__DEV__) &#123;<br>    <span class="hljs-comment">// 这里是一些针对 __DEV__ 环境下的处理，对于大家理解主要逻辑意义不大，此处我直接省略掉，以免混淆视听</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> element;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>designmode</title>
    <link href="/2020/09/23/designmode-1/"/>
    <url>/2020/09/23/designmode-1/</url>
    
    <content type="html"><![CDATA[<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简单工厂模式 不同类型</span><br><br><span class="hljs-comment">// 将创建对象的过程封装</span><br><br><span class="hljs-keyword">var</span> Dog = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br>&#125;;<br><br>Dog.prototype = &#123;<br><br>&#125;<br><br><span class="hljs-keyword">var</span> Cat = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br>&#125;;<br><br>Cat.prototype = &#123;<br><br>&#125;<br><br><span class="hljs-keyword">var</span> FactoryEasy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">switch</span>(name)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dog&#x27;</span>:<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;cat&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cat();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 同类型</span><br><br><br><br><span class="hljs-keyword">var</span> Factory = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br>    <span class="hljs-keyword">switch</span>(name)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dog&#x27;</span>:<br>            o.name = <span class="hljs-string">&#x27;dog&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;cat&#x27;</span>:<br>            o.name= <span class="hljs-string">&#x27;cat&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 同类型，避免重复写构造函数</span><br><br><span class="hljs-keyword">var</span> Animal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> Factory = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> work = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>    <span class="hljs-keyword">switch</span>(name)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dog&#x27;</span>:<br>            work = <span class="hljs-string">&#x27;dog&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;cat&#x27;</span>:<br>            work = <span class="hljs-string">&#x27;cat&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Animal(work)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>适用于创建多类对象，使使用者与类解耦，增加或者减少类不会影响工厂函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// </span><br><br><span class="hljs-keyword">var</span> Factory = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name,options</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> Factory)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">this</span>[name](options)<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Factory(name,options)<br>    &#125;<br>&#125;<br><br>Factory.prototype = &#123;<br>    dog:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;<br><br>    &#125;,<br>    cat: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">opstions</span>) </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>一个类只允许实例化一次, 利用闭包保证一个类只被实例化一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> singleObj = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> single = <span class="hljs-literal">null</span>;<br><br><br>    <span class="hljs-comment">// 保证func只创建一次</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;aa&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!single)&#123;<br>            single = <span class="hljs-keyword">new</span> func()<br>            <span class="hljs-keyword">return</span> single;<br>        &#125;<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br><br>&#125;)();<br><br></code></pre></td></tr></table></figure><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰模式 只添加不修改，不改变原有方法功能的情况，增强功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// </span><br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">111</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 为oldobj增加新功能</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">222</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> newa = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    a();<br>    <span class="hljs-comment">// 新增逻辑</span><br>    b();<br>&#125;<br><br><br><br><span class="hljs-comment">// 事件装饰器</span><br><br><span class="hljs-keyword">var</span> decorator = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector, fn</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> ele = <span class="hljs-built_in">document</span>.querySelector(selector);<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> ele.onclick === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>        <span class="hljs-keyword">var</span> oldfn = ele.onclick;<br><br>        ele.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 执行旧代码</span><br>            oldfn();<br>            <span class="hljs-comment">// 执行新增代码</span><br>            fn();<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        ele.onclick = fn()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 适配器 磨平兼容差异，把变化内部磨平，变化暴露给外部</span><br><br><span class="hljs-comment">// 默认参数适配器</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">options</span>) </span>&#123;<br><br>    <span class="hljs-keyword">var</span> _adapter = &#123;<br>        a: <span class="hljs-string">&#x27;12&#x27;</span>,<br>        b: <span class="hljs-number">12</span><br>    &#125;<br><br>    <span class="hljs-comment">// 插件参数配置</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> _adapter)&#123;<br>        options[i] = options[i] || _adapter[i]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理服务端数据</span><br><br>$.ajax(&#123;<br>    success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>        handle(_adapter(data))<br>    &#125;<br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_adapter</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-comment">// 处理好格式再传递，以后格式变化，改这里就行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(data)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>inherit</title>
    <link href="/2020/09/10/inherit/"/>
    <url>/2020/09/10/inherit/</url>
    
    <content type="html"><![CDATA[<h3 id="经典继承"><a href="#经典继承" class="headerlink" title="经典继承"></a>经典继承</h3><p>借用构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 经典继承</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>];<br>&#125;<br><br>Super.prototype.say= <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    Super.call(<span class="hljs-built_in">this</span>,name);<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Sub(<span class="hljs-string">&quot;a&quot;</span>);<br>a.colors.push(<span class="hljs-string">&quot;yellow&quot;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Sub(<span class="hljs-string">&quot;b&quot;</span>);<br><br><span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;, &quot;yellow&quot;]  name: &quot;a&quot;</span><br>                <br>                 <br><span class="hljs-built_in">console</span>.log(b);<span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;&quot;]  name: &quot;b&quot;</span><br><br>a.say(); <span class="hljs-comment">//  Uncaught TypeError: a.say is not a function</span><br></code></pre></td></tr></table></figure><p>优点： 隔离了超类的共享属性<br>缺点： 无法复用父类原型方法</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// 原型链继承</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>];<br>&#125;<br><br>Super.prototype.say= <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">name</span>) </span>&#123;<br>   <span class="hljs-built_in">this</span>.name = name<br>&#125;<br><br>Sub.prototype = <span class="hljs-keyword">new</span> Super();<br><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Sub();<br>a.colors.push(<span class="hljs-string">&quot;yellow&quot;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Sub();<br><br><br><span class="hljs-built_in">console</span>.log(a.__proto__); <span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;, &quot;yellow&quot;] </span><br><span class="hljs-built_in">console</span>.log(b.__proto__);<span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;, &quot;yellow&quot;] </span><br>a.say(); <span class="hljs-comment">// &#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p>优点：继承了超类原型方法<br>缺点：超类中的引用属性做不到隔离</p><h3 id="组合试继承"><a href="#组合试继承" class="headerlink" title="组合试继承"></a>组合试继承</h3><p>结合经典继承与原型链继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 组合式继承</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>];<br>&#125;<br><br>Super.prototype.say= <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">name,age</span>) </span>&#123;<br>    Super.call(<span class="hljs-built_in">this</span>,name);<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br>Sub.prototype = <span class="hljs-keyword">new</span> Super();<br><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Sub(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">21</span>);<br>a.colors.push(<span class="hljs-string">&quot;yellow&quot;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Sub(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">22</span>);<br><br><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// age: 21</span><br>                 <span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;, &quot;yellow&quot;]</span><br>                  <span class="hljs-comment">// name: &quot;a&quot;</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">//age: 22</span><br>                 <span class="hljs-comment">// colors: (3) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;]</span><br>                <span class="hljs-comment">//  name: &quot;b&quot;</span><br>a.say(); <span class="hljs-comment">// ‘a’</span><br></code></pre></td></tr></table></figure><p>优点：隔离超类引用类型属性，复用原型方法<br>缺点：超类构造函数被调用2次</p><h3 id="寄生式"><a href="#寄生式" class="headerlink" title="寄生式"></a>寄生式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 原型链继承</span><br><br><span class="hljs-keyword">var</span> Super = &#123;<br>    name: <span class="hljs-string">&#x27;12&#x27;</span>,<br>    colors:[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">obj</span>) </span>&#123;<br><br><span class="hljs-comment">// 等价于 var f = function()&#123;&#125;; f.prototype = obj; var o = new f();</span><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Object</span>.create(obj); <br>    <span class="hljs-comment">// 增强对象，增加属性方法</span><br>    <br>    <span class="hljs-comment">// new 对象的本质</span><br>    <br>   <span class="hljs-comment">// 1.new 一个新对象</span><br>   <span class="hljs-comment">// 2.obj.__proto__ = 构造函数.原型 </span><br>   <span class="hljs-comment">// 3.执行构造函数，call(this,arguments);</span><br>   <span class="hljs-comment">// 4.返回这个对象</span><br>    <br>    <br>    <span class="hljs-comment">// 通过new 方法，默认返回this 指向Sub的原型，这里强制覆盖</span><br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Sub(Super);<br>a.colors.push(<span class="hljs-string">&quot;yellow&quot;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Sub(Super);<br><br><span class="hljs-built_in">console</span>.log(a.__proto__); <span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;, &quot;yellow&quot;] </span><br><span class="hljs-built_in">console</span>.log(b.__proto__);<span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;, &quot;yellow&quot;] </span><br></code></pre></td></tr></table></figure><h3 id="寄生组合式"><a href="#寄生组合式" class="headerlink" title="寄生组合式"></a>寄生组合式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 寄生组合式继承</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>];<br>&#125;<br><br>Super.prototype.say= <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">name,age</span>) </span>&#123;<br>    Super.call(<span class="hljs-built_in">this</span>,name);<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">Sub, Super</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> proto = <span class="hljs-built_in">Object</span>.create(Super.prototype); <span class="hljs-comment">// Super 的一个实例</span><br>    proto.constructor = Sub; <span class="hljs-comment">// 增强对象，复写子类原型会导致constructor 指向丢失</span><br>    Sub.prototype = proto; <span class="hljs-comment">// 原型链继承</span><br>&#125;<br><br>inheritPrototype(Sub, Super);<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Sub(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">21</span>);<br>a.colors.push(<span class="hljs-string">&quot;yellow&quot;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Sub(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">22</span>);<br><br><br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-built_in">console</span>.log(b);<br>a.say();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>chromev8</title>
    <link href="/2020/08/08/chromev8/"/>
    <url>/2020/08/08/chromev8/</url>
    
    <content type="html"><![CDATA[<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>编译型语言在程序执行之前需要先经过编译，将其编译为机器可以理解的二进制文件，c&#x2F;c++ go<br>编译过程：</p><p>源代码——&gt;词法分析、语法分析-&gt;AST-&gt;生成中间代码-&gt;代码优化-&gt;二进制文件-&gt;执行</p><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>解释型语言需要每次在运行时都对程序进行动态解释再执行</p><p>编译过程：</p><p>源代码——&gt;词法分析、语法分析-&gt;AST-&gt;字节码-&gt;解释执行-&gt;执行</p><h3 id="v8-如何执行一段代码"><a href="#v8-如何执行一段代码" class="headerlink" title="v8 如何执行一段代码"></a>v8 如何执行一段代码</h3><p><img src="/images/v8.png"></p><p>1.生成抽象语法树和执行上下文<br>AST 是一种结构，生成它的步骤：分词（tokenize)，将代码分成最小单元；解析，语法分析，将token 数据转成AST</p><p>2.生成字节码</p><p>一开始v8没有字节码，直接将AST装成机器码，执行效率非常高，但是占用内存大，低端机器扛不住。<br>为了解决内存问题，引入了字节码。</p><p>字节码：介于AST 和 机器之前的一种代码，需要被解释器转成机器码了才能执行</p><p>机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用</p><p>3.执行阶段</p><p>通常，第一次执行的字节码，解释器lgnition和逐条解释。在执行的字节码的过程中，<br>如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率</p><h3 id="即时编译-JIT"><a href="#即时编译-JIT" class="headerlink" title="即时编译 JIT"></a>即时编译 JIT</h3><p>字节码 与 解释器、编译器相结合；<br>v8中的解释： 代码每次执行的时候都会进行编译，编译为字节码的时候，解释器需要进行逐条解释，但是如果这段代码被标记为了热点代码，编译器就将它直接编译为了机器代码并保存在内存中，<br>下次会直接使用内存中的机器码，而不需要逐条解释为机器码</p><h3 id="js性能优化"><a href="#js性能优化" class="headerlink" title="js性能优化"></a>js性能优化</h3><p>代码层面的优化，v8已经做到极致了，我们要将重心放在单次脚本的运行时间和网络下载上</p><p>1.单次脚本的执行时间<br>2.避免过大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；<br>3.减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存</p>]]></content>
    
    
    
    <tags>
      
      <tag>browser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>garbageCollection</title>
    <link href="/2020/07/27/garbageCollection/"/>
    <url>/2020/07/27/garbageCollection/</url>
    
    <content type="html"><![CDATA[<h3 id="栈中垃圾回收"><a href="#栈中垃圾回收" class="headerlink" title="栈中垃圾回收"></a>栈中垃圾回收</h3><p>记录当前执行上下文状态的指针称为ESP</p><p>JavaScript引擎通过向下移动ESP来销毁该函数保存在栈中的执行上下文</p><h3 id="堆内存中的垃圾回收"><a href="#堆内存中的垃圾回收" class="headerlink" title="堆内存中的垃圾回收"></a>堆内存中的垃圾回收</h3><p>代际假说：（The Generational Hypothesis）<br>1.大部分对象在内存中的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；<br>2.不死的对象，活的更久</p><p>v8引擎会把堆分成新生代和老生代两个区域，新生代放置生存时间短的（大小通常为8M)，老生代放置存活时间长的对象<br>（容量一般大于8M)</p><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p>1.副垃圾回收器，只要负责新生代的垃圾回收<br>副垃圾回收器中的对象通常是较小的对象，区域不大，但是回收频繁。<br>新生代中使用Scavenge算法，将新生代的区域分为2半，一半为对象区域，一半为空闲区域<br>新的对象会被加入到对象区域，当对象区域快写满时，就要进行一次垃圾回收。<br>对象区域中的垃圾进行标记-&gt; 副垃圾回收器将活动对象复制到空闲区域,同时会将对象有序的排序（不会产生内存碎片的原因)<br>-&gt;将对象区域与空闲区域的角色进行翻转</p><p>2.主垃圾回收器，主要负责老生代的垃圾回收<br>新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。<br>主垃圾回收器采用的是标记-清楚算法（ Mark-Sweep ）<br>从根元素开始，递归根元素(不能到达的元素，标记为垃圾)-&gt;直接对垃圾数据进行回收<br>标记 - 整理（ Mark-Compact ）<br>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p><h4 id="回收器的工作流程"><a href="#回收器的工作流程" class="headerlink" title="回收器的工作流程"></a>回收器的工作流程</h4><p>1.标记空间中的活动对象与非活动对象，活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象<br>2.回收非活动对象所占据的内存。。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。<br>3.内存整理。垃圾回收之后，内存中会存在大量不连续的内存空间称为内存碎片（不是所有的回收器都会产生内存碎片，例如副垃圾回收器)</p><h4 id="对象晋升策略"><a href="#对象晋升策略" class="headerlink" title="对象晋升策略"></a>对象晋升策略</h4><p>当一个对象经历过2次垃圾回收依然存在，会被移动到老生代中</p><h4 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h4><p>由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）</p><p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>store of data</title>
    <link href="/2020/07/23/memory/"/>
    <url>/2020/07/23/memory/</url>
    
    <content type="html"><![CDATA[<h3 id="栈内存与堆内存如何存储数据"><a href="#栈内存与堆内存如何存储数据" class="headerlink" title="栈内存与堆内存如何存储数据"></a>栈内存与堆内存如何存储数据</h3><p>值类型的数据通常保存在栈中，栈空间用来保存执行上下文<br>引用类型的数据通常保存在堆中，并且在栈中留下引用</p><p>栈空间需要用来维护程序执行期间执行上下文的状态，为了提高执行上下文的切换效率，栈的空间一定要相对来说较小</p><h3 id="闭包的内存模型"><a href="#闭包的内存模型" class="headerlink" title="闭包的内存模型"></a>闭包的内存模型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>    <span class="hljs-keyword">let</span> test1 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> test2 = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> innerBar = &#123; <br>        setName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newName</span>)</span>&#123;<br>            myName = newName<br>        &#125;,<br>        getName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(test1)<br>            <span class="hljs-keyword">return</span> myName<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> innerBar<br>&#125;<br><span class="hljs-keyword">var</span> bar = foo()<br>bar.setName(<span class="hljs-string">&quot; 极客邦 &quot;</span>)<br>bar.getName()<br><span class="hljs-built_in">console</span>.log(bar.getName())<br></code></pre></td></tr></table></figure><p>1.首先会创建一个全局执行上下文<br>2.执行到foo函数时，会先进行编译，创建foo函数的执行上下文<br>3.遇到内部函数时，还要对内部函数做一个快速的词法扫描，内部函数引用了外部变量，在堆内存中创建一个closure闭包对象，这个对象会同时包含值与引用2种数据<br>4.这个closure对象保存在变量环境中，由于闭包的特殊性，即使函数执行完毕了，但是返回的对象中的函数依然保留了它的引用</p><p>产生闭包的核心：<br>第一步是需要预扫描内部函数；<br>第二步是把内部函数引用的外部变量保存到堆中</p><p>执行上下文的销毁过程：<br>关于foo函数执行上下文销毁过程：foo函数执行结束之后，当前执行状态的指针下移到栈中的全局执行上下文的位置，foo函数的执行上下文的那块数据就挪出来，这也就是foo函数执行上下文的销毁过程，这个文中有提到，你可以参考“调用栈中切换执行上下文状态“图。</p><p>第二个问题：innerBar返回后，含有setName和getName对象，这两个对象里面包含了堆中的closure(foo)的引用。虽然foo执行上下文销毁了，foo函数中的对closure(foo)的引用也断开了，但是setName和getName里面又重新建立起来了对closure(foo)引用</p><h3 id="执行上下文如何切换"><a href="#执行上下文如何切换" class="headerlink" title="执行上下文如何切换"></a>执行上下文如何切换</h3><p>只需要将指针下移到上个执行上下文的地址就可以了，当前执行上下文栈区空间全部回收，堆中的数据依然保留</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>understand  this &amp; scope chain</title>
    <link href="/2020/07/22/this/"/>
    <url>/2020/07/22/this/</url>
    
    <content type="html"><![CDATA[<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>执行上下文中除了变量环境、词法环境、outer还有this，this是和执行上下文绑定的<br>在对象内部方法中使用对象内部的属性。作用域链与this是2个独立的不同的系统</p><h3 id="判断要数"><a href="#判断要数" class="headerlink" title="判断要数"></a>判断要数</h3><p>this 的绑定和函数声明的位置无关，只取决于函数的调用方式,看它真实的调用的对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>    bar(); <span class="hljs-comment">// ReferenceError 这里是全局作用域 this指向window</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br>foo();<br><br></code></pre></td></tr></table></figure><p>变量的查找与this无关，这里bar函数中的a，查找过程是通过作用域链查找的，向上只能到全局作用域</p><h3 id="this的绑定"><a href="#this的绑定" class="headerlink" title="this的绑定"></a>this的绑定</h3><p>1.默认绑定<br>独立的函数调用，无法调用其他规则时的默认规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a); <span class="hljs-comment">// 2</span><br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>foo();<br><br>这里的foo没有任何修饰符，使用了默认绑定，<span class="hljs-built_in">this</span>指向全局<span class="hljs-built_in">window</span><br>但是如果是严格模式，<span class="hljs-built_in">this</span>并不指向<span class="hljs-built_in">window</span>，而是<span class="hljs-literal">undefined</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a); <span class="hljs-comment">// TypeError this is undefined</span><br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>foo();<br><br></code></pre></td></tr></table></figure><p>注意第三方库的strict应用范围,foo在非严格模式 this会绑定到全局，调用foo不影响默认绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a); <span class="hljs-comment">// 2</span><br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span><br>    foo();<br>&#125;)();<br></code></pre></td></tr></table></figure><p>2.隐式绑定<br>当函数引用有上下文对象时，隐式绑定规则会将this绑定到这个上下文对象上，对象属性引用链只有上一层或者说最后一层起作用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj2 = &#123;<br>    a: <span class="hljs-number">42</span>,<br>    foo: foo<br>&#125;<br><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    a:<span class="hljs-number">2</span>,<br>    obj2:obj1<br>&#125;<br><br>obj1.obj2.foo(); <span class="hljs-comment">// 42</span><br><br></code></pre></td></tr></table></figure><p>隐式丢失，传入回调函数时常发生</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> bar = &#123;<br>    a : <span class="hljs-number">1</span>,<br>    foo: foo<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doFoo</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>    fn();<br>&#125;<br><br><br>doFoo(bar.foo); <span class="hljs-comment">//2</span><br><br></code></pre></td></tr></table></figure><p>bar.foo 实际上指向的是foo函数本身， 函数传参其实一种隐式赋值，这里doFoo使用了默认绑定规则，this指向了widow</p><p>3.显示绑定</p><p>使用call apply显示的将函数的this绑定到某一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    a: <span class="hljs-number">2</span><br>&#125;<br><br>foo.call(obj);<span class="hljs-comment">//2</span><br><br>如果传入了一个原始值、字符创、布尔、数值 来作为<span class="hljs-built_in">this</span>的绑定对象，会先进行装箱<br></code></pre></td></tr></table></figure><p>硬绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>&#125;<br><br><br><span class="hljs-keyword">var</span> bar = &#123;<br>    a : <span class="hljs-number">1</span>,<br>    foo: foo<br>&#125;<br><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//setTimeout(bar.foo);// 会产生绑定隐式丢失</span><br><br><br><span class="hljs-comment">//创建一个baz将foo的this强制绑定到bar</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params"></span>)</span>&#123;<br>    foo.call(bar);<br>&#125;<br><br><span class="hljs-comment">//同 Function.prototype.bind</span><br><br><span class="hljs-built_in">setTimeout</span>(baz);<span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p>4.new 绑定<br>  调用new 发生什么？</p><p>  1.创建一个新对象<br>  2.执行[[Prototype]]链接<br>  3.将新对象绑定到函数调用的this<br>  4.如果没有其它返回则返回这个新对象</p><p>  var obj &#x3D; {};<br>  obj.<strong>proto</strong> &#x3D; foo.prototype;<br>  foo.call(obj);<br>  return obj;</p><p>  调用new 时， this绑定到新创建的对象上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.a = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> foo();<span class="hljs-comment">// this-&gt;bar</span><br>bar.a;<span class="hljs-comment">//2</span><br><br></code></pre></td></tr></table></figure><p>优先级：</p><p>默认绑定优先级最低。</p><p>显示绑定与隐式绑定：显示绑定优于隐式绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> bar = &#123;<br>    a:<span class="hljs-number">1</span>,<br>    foo:foo<br>&#125;<br><br><span class="hljs-keyword">var</span> baz = &#123;<br>    a:<span class="hljs-number">2</span>,<br>    foo:foo<br>&#125;<br><br><span class="hljs-comment">//隐式</span><br>bar.foo(); <span class="hljs-comment">// 1</span><br>baz.foo(); <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// 显示</span><br><br>bar.foo.call(baz); <span class="hljs-comment">// 2</span><br>baz.foo.call(bar); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>隐式与new 绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.a = s;<br>&#125;<br><br><span class="hljs-keyword">var</span> bar = &#123;<br>    foo:foo<br>&#125;<br><br>bar.foo(<span class="hljs-number">2</span>);<br>bar.a;<span class="hljs-comment">//2</span><br><br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> bar.foo(<span class="hljs-number">4</span>);<br>baz.a;<span class="hljs-comment">//4</span><br></code></pre></td></tr></table></figure><p>new –&gt; 显示、硬绑定–&gt; 隐式绑定–&gt;默认绑定</p><p>绑定例外：</p><p>当不关注this指向的时候，可以传入null，此时会使用默认绑定规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">foo.apply(<span class="hljs-literal">null</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p>安全的this<br>防止this指向全局，我们可以传入一个安全的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ø = <span class="hljs-built_in">Object</span>(<span class="hljs-literal">null</span>);<br>foo.apply(ø,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>箭头函数不受四种规则影响，它根据外层作用域的this决定</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1.当函数作为对象的方法调用时，函数中的 this 就是该对象；<br>2.当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；<br>3.嵌套函数中的 this 不会继承外层函数的 this 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObj = &#123;<br>  name : <span class="hljs-string">&quot; 11 &quot;</span>, <br>  showThis: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)&#125;<br>    bar(); <br>  &#125;<br>&#125;<br>myObj.showThis()<br></code></pre></td></tr></table></figure><p>bar函数中的this被默认绑定到了window上面，它的调用对象可以看做是window<br>解决方法self &#x3D; this利用闭包构建作用域链；或者箭头函数</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>lexicalspcope &amp; 闭包</title>
    <link href="/2020/07/21/lexicalspcope/"/>
    <url>/2020/07/21/lexicalspcope/</url>
    
    <content type="html"><![CDATA[<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>每个执行上下文中的变量环境中都包含了一个外部应用，用来指向外部引用，我们称之为outer</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(myName)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 111 &quot;</span><br>    bar()<br>&#125;<br><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 22 &quot;</span><br>foo()<br></code></pre></td></tr></table></figure><p>执行到bar的console时，先从bar执行环境中的词法环境中查找变量，没有则从变量环境中查找，仍然没有，<br>通过外部引用查找，这个outer指向了全局执行上下文，获取到myName 22</p><p>词法环境-&gt;变量环境-&gt;外部引用-&gt;全局环境的查找链，就叫做作用域链</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>词法作用域又称静态作用域，因为它是由代码中函数生成的位置决定的，与其它无关，可以预测代码执行过程中如何查找标识符</p><p>词法作用域定义了变量环境中outer 的指向</p><p>bar中外部引用根据词法作用域指向了全局执行上下文而不是foo的执行上下文</p><h3 id="块级作用域中的变量查找"><a href="#块级作用域中的变量查找" class="headerlink" title="块级作用域中的变量查找"></a>块级作用域中的变量查找</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 极客世界 &quot;</span><br>    <span class="hljs-keyword">let</span> test1 = <span class="hljs-number">100</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot;Chrome 浏览器 &quot;</span><br>        <span class="hljs-built_in">console</span>.log(test)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 极客邦 &quot;</span><br>    <span class="hljs-keyword">let</span> test = <span class="hljs-number">2</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> test = <span class="hljs-number">3</span><br>        bar()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br><span class="hljs-keyword">let</span> myAge = <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> test = <span class="hljs-number">1</span><br>foo()<br></code></pre></td></tr></table></figure><p><img src="/images/lexicalscope.png"></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>词法作用域规定，内部函数总是可以访问外部函数中声明的变量。<br>当调用一个外部函数返回内部函数，即使外部函数已经执行完了，但是内部函数引用外部函数的变量依然<br>保存在内存中，这些变量的集合称为闭包，只要应用在，依然可以重新建立联系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>    <span class="hljs-keyword">let</span> test1 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> test2 = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> innerBar = &#123;<br>        getName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(test1)<br>            <span class="hljs-keyword">return</span> myName<br>        &#125;,<br>        setName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newName</span>)</span>&#123;<br>            myName = newName<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> innerBar<br>&#125;<br><span class="hljs-keyword">var</span> bar = foo()<br>bar.setName(<span class="hljs-string">&quot; 极客邦 &quot;</span>)<br>bar.getName()<br><span class="hljs-built_in">console</span>.log(bar.getName())<br></code></pre></td></tr></table></figure><p>即使foo执行完毕，但是它返回的innerbar 对象包含了foo内部的引用，test1、myName<br>当执行到 bar.setName 方法中的myName &#x3D; “极客邦”这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文”的顺序来查找 myName 变量，你可以参考下面的调用栈状态图</p><p>首先是setName的执行上下文中查找myName,然后在它的变量环境中通过外部引用找到foo的闭包<br><img src="/images/lexicalscope_2.png"></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1.变量的查找流程？<br>2.理解词法作用域、作用域链、闭包<br>3.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = &#123;<br>    myName:<span class="hljs-string">&quot;time.geekbang.com&quot;</span>,<br>    printName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(myName)<br>    &#125;    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>    <span class="hljs-keyword">return</span> bar.printName<br>&#125;<br><span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot; 极客邦 &quot;</span><br><span class="hljs-keyword">let</span> _printName = foo()<br>_printName()<br>bar.printName()<br></code></pre></td></tr></table></figure><pre><code>    function buildLocationTree(nodeList)&#123;        var nodes = [];        var root = &#123;            root: nodes        &#125;        for(var i = 0; i &lt; nodeList.length; i++)&#123;            var ele = nodeList[i];            var deep = ele.id;            if(!deep)&#123;                nodes.push(createNode(ele.id,ele.name, ele.subLocations, pid))            &#125;else &#123;                var target = nodes;                while(pid&gt;0)&#123;                    if(!target.subLocations)&#123;                        target.subLocations = [];                    &#125;                    pid--;                    target = target.subLocations                &#125;                target.push(createNode(ele.id,ele.name, ele.subLocations, pid))            &#125;        &#125;        return root;    &#125;    function createNode (id, name, subLocations, pid)&#123;        return &#123;            id,            name,            subLocations,            pid         &#125;    &#125;</code></pre><p>  function sort(arr){<br>    if(arr.length &lt; 2){<br>      return arr<br>    }</p><pre><code>var arrUnit = arr[5000].timestamp;var left = [],    right = [];for(var i = 1; i &lt; arr.length; i++)&#123;  if( arr[i].timestamp &lt; arrUnit)&#123;    left.push(arr[i]);  &#125;else &#123;    right.push(arr[i]);  &#125;&#125;    return sort(left).concat(arrUnit,sort(right))&#125;function matchNum(str)&#123;        return str.match(/uin=\D*(\d+)/)[1];&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>scope</title>
    <link href="/2020/07/20/scope/"/>
    <url>/2020/07/20/scope/</url>
    
    <content type="html"><![CDATA[<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域决定了一段代码能访问到那些数据，这些数据保存在词法环境对象中<br>变量与函数的作用范围，控制着变量与函数的可见性与声明周期</p><p>es6 之前只有全局作用域与函数作用域。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>为了解决变量提升带来的覆盖与污染问题，出现了块级作用域 const、let</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span><br>    &#123;<br>      <span class="hljs-keyword">let</span> b = <span class="hljs-number">3</span><br>      <span class="hljs-keyword">var</span> c = <span class="hljs-number">4</span><br>      <span class="hljs-keyword">let</span> d = <span class="hljs-number">5</span><br>      <span class="hljs-built_in">console</span>.log(a)<br>      <span class="hljs-built_in">console</span>.log(b)<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(b) <br>    <span class="hljs-built_in">console</span>.log(c)<br>    <span class="hljs-built_in">console</span>.log(d)<br>&#125;   <br>foo()<br></code></pre></td></tr></table></figure><p>1.函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。<br>2.通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。<br>3.在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中</p><p>执行这个作用域块的时候，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中<br>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量<br>当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。</p><h3 id="变量提升与块级作用域的提升"><a href="#变量提升与块级作用域的提升" class="headerlink" title="变量提升与块级作用域的提升"></a>变量提升与块级作用域的提升</h3><p>变量环境实现函数级作用域：<br>执行一个函数时，会创建一个执行上下文，其中的变量环境会保存该函数代码内生成的变量</p><p>块级作用域通过词法环境的栈结构实现</p><h3 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h3><p>函数只会在第一次执行的时候被编译，所以编译时变量环境和词法环境最顶层数据已经确定了。</p><p>当执行到块级作用域的时候，块级作用域中通过let和const申明的变量会被追加到词法环境中，当这个块执行结束之后，追加到词法作用域的内容又会销毁掉。</p><p>参考：<br><a href="https://www.jianshu.com/p/0fcc26e13300">https://www.jianshu.com/p/0fcc26e13300</a></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1.函数级作用域如何实现？<br>2.块级作用域又是如何实现的？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>javascript 执行上下文与调用栈</title>
    <link href="/2020/07/16/javascript/"/>
    <url>/2020/07/16/javascript/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>执行上下文：js执行一段代码时的运行环境。</p><p>调用栈：是一种用来管理函数之间调用关系的数据结构。</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>在执行一段代码时，会做一些准备工作，代码先进行编译后执行，编译的时候就会产生可执行代码与执行上下文。<br>词法分析-&gt;语法分析-&gt;代码生成</p><p>创建执行上下文的三种情况：<br>1.执行全局代码时，会生成全局上下文，整个页面的生命周期内，全局上下文唯一<br>2.函数被调用时，函数体内的代码会被编译，创建函数执行上下文，无闭包的话使用完之后就被销毁<br>3.eval被执行时，eval内的代码被编译，创建执行上下文</p><p><img src="/images/stack_2.png"></p><h3 id="执行上下文包含的属性"><a href="#执行上下文包含的属性" class="headerlink" title="执行上下文包含的属性"></a>执行上下文包含的属性</h3><p>1.变量环境组件： 指定一个词法环境对象，其环境数据用于保存由该执行环境内的代码通过var 与 functionDeclartion创建的绑定<br>2.词法环境组件：指定一个词法环境对象，用于解析该执行环境内的代码创建的标识符引用；<br>3.this ：指定该环境this关键字关联的值</p><p>每个词法环境对象包含2部分：<br>环境记录器<br>外部环境的引用（全局词法环境为空)</p><p>环境记录器<br>环境记录器分为两种：<br>1）声明式环境记录器<br>存在于函数作用域中，存储变量、函数、参数。<br>2）对象式环境记录器<br>存在于全局作用域和块级作用域中，存储变量、函数</p><p>外部环境引用<br>如果在当前环境内找不到变量，引擎可以通过引用在外部环境继续查找</p><p>其中执行环境的词法环境和变量环境组件始终为词法环境对象。当创建一个执行环境时，其词法环境组件和变量环境组件最初是同一个值。在该执行环境相关联的代码的执行过程中，变量环境组件永远不变，而词法环境组件有可能改变</p><p>词法环境中，进入或者退出一个块级作用域，里面的数据都会改变</p><p>区别是：<br>let、const声明的变量，外部环境引用保存在词法环境组件中。<br>var和function声明的变量，外部环境引用保存在环境变量组件中</p><h3 id="如何管理执行上下文？"><a href="#如何管理执行上下文？" class="headerlink" title="如何管理执行上下文？"></a>如何管理执行上下文？</h3><p>创建一个执行上下文栈(Execution context stack, ECS),又称调用栈</p><p>JavaScript引擎使用栈的结构来管理执行上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">b,c</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> b+c<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAll</span>(<span class="hljs-params">b,c</span>)</span>&#123;<br><span class="hljs-keyword">var</span> d = <span class="hljs-number">10</span><br>result = add(b,c)<br><span class="hljs-keyword">return</span>  a+result+d<br>&#125;<br>addAll(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>第一步： 代码编译，创建全局上下文，并将其压入栈底<br><img src="/images/stack_1.png"></p><p>第二步： 调用addAll函数，编译addAll函数并创建函数执行上下文，将它压入栈中</p><p>第三步： 执行addAll函数，到add函数时，编译add函数并创建执行上下文，压入栈中</p><p>第四部：执行add函数，返回结果，将add函数弹出栈</p><p>第五步：addAll函数中拿到result结果，返回结果，将addAll上下文也弹出</p><p>第六步： 返回结果，执行完毕</p><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>栈的最大容量和深度都是有限制的，超出限制，就会抛出错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Maximum call stack size exceeded<br></code></pre></td></tr></table></figure><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1.什么是执行上下文，它包含了哪些属性？<br>2.变量环境与词法环境的相同点与差异点？</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

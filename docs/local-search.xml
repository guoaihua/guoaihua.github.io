<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>designmode</title>
    <link href="/2020/09/23/designmode-1/"/>
    <url>/2020/09/23/designmode-1/</url>
    
    <content type="html"><![CDATA[<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简单工厂模式 不同类型</span><br><br><span class="hljs-comment">// 将创建对象的过程封装</span><br><br><span class="hljs-keyword">var</span> Dog = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br>&#125;;<br><br>Dog.prototype = &#123;<br><br>&#125;<br><br><span class="hljs-keyword">var</span> Cat = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br>&#125;;<br><br>Cat.prototype = &#123;<br><br>&#125;<br><br><span class="hljs-keyword">var</span> FactoryEasy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">switch</span>(name)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dog&#x27;</span>:<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;cat&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cat();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 同类型</span><br><br><br><br><span class="hljs-keyword">var</span> Factory = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br>    <span class="hljs-keyword">switch</span>(name)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dog&#x27;</span>:<br>            o.name = <span class="hljs-string">&#x27;dog&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;cat&#x27;</span>:<br>            o.name= <span class="hljs-string">&#x27;cat&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 同类型，避免重复写构造函数</span><br><br><span class="hljs-keyword">var</span> Animal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> Factory = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> work = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>    <span class="hljs-keyword">switch</span>(name)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dog&#x27;</span>:<br>            work = <span class="hljs-string">&#x27;dog&#x27;</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;cat&#x27;</span>:<br>            work = <span class="hljs-string">&#x27;cat&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Animal(work)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>适用于创建多类对象，使使用者与类解耦，增加或者减少类不会影响工厂函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// </span><br><br><span class="hljs-keyword">var</span> Factory = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name,options</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> Factory)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">this</span>[name](options)<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Factory(name,options)<br>    &#125;<br>&#125;<br><br>Factory.prototype = &#123;<br>    dog:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;<br><br>    &#125;,<br>    cat: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">opstions</span>) </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>一个类只允许实例化一次, 利用闭包保证一个类只被实例化一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> singleObj = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> single = <span class="hljs-literal">null</span>;<br><br><br>    <span class="hljs-comment">// 保证func只创建一次</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;aa&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!single)&#123;<br>            single = <span class="hljs-keyword">new</span> func()<br>            <span class="hljs-keyword">return</span> single;<br>        &#125;<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br><br>&#125;)();<br><br></code></pre></td></tr></table></figure><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰模式 只添加不修改，不改变原有方法功能的情况，增强功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// </span><br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">111</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 为oldobj增加新功能</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">222</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> newa = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    a();<br>    <span class="hljs-comment">// 新增逻辑</span><br>    b();<br>&#125;<br><br><br><br><span class="hljs-comment">// 事件装饰器</span><br><br><span class="hljs-keyword">var</span> decorator = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">selector, fn</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> ele = <span class="hljs-built_in">document</span>.querySelector(selector);<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> ele.onclick === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>        <span class="hljs-keyword">var</span> oldfn = ele.onclick;<br><br>        ele.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// 执行旧代码</span><br>            oldfn();<br>            <span class="hljs-comment">// 执行新增代码</span><br>            fn();<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        ele.onclick = fn()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 适配器 磨平兼容差异，把变化内部磨平，变化暴露给外部</span><br><br><span class="hljs-comment">// 默认参数适配器</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">options</span>) </span>&#123;<br><br>    <span class="hljs-keyword">var</span> _adapter = &#123;<br>        a: <span class="hljs-string">&#x27;12&#x27;</span>,<br>        b: <span class="hljs-number">12</span><br>    &#125;<br><br>    <span class="hljs-comment">// 插件参数配置</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> _adapter)&#123;<br>        options[i] = options[i] || _adapter[i]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 处理服务端数据</span><br><br>$.ajax(&#123;<br>    success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>        handle(_adapter(data))<br>    &#125;<br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_adapter</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-comment">// 处理好格式再传递，以后格式变化，改这里就行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(data)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>inherit</title>
    <link href="/2020/09/10/inherit/"/>
    <url>/2020/09/10/inherit/</url>
    
    <content type="html"><![CDATA[<h3 id="经典继承"><a href="#经典继承" class="headerlink" title="经典继承"></a>经典继承</h3><p>借用构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 经典继承</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>];<br>&#125;<br><br>Super.prototype.say= <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    Super.call(<span class="hljs-built_in">this</span>,name);<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Sub(<span class="hljs-string">&quot;a&quot;</span>);<br>a.colors.push(<span class="hljs-string">&quot;yellow&quot;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Sub(<span class="hljs-string">&quot;b&quot;</span>);<br><br><span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;, &quot;yellow&quot;]  name: &quot;a&quot;</span><br>                <br>                 <br><span class="hljs-built_in">console</span>.log(b);<span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;&quot;]  name: &quot;b&quot;</span><br><br>a.say(); <span class="hljs-comment">//  Uncaught TypeError: a.say is not a function</span><br></code></pre></td></tr></table></figure><p>优点： 隔离了超类的共享属性<br>缺点： 无法复用父类原型方法</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// 原型链继承</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>];<br>&#125;<br><br>Super.prototype.say= <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">name</span>) </span>&#123;<br>   <span class="hljs-built_in">this</span>.name = name<br>&#125;<br><br>Sub.prototype = <span class="hljs-keyword">new</span> Super();<br><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Sub();<br>a.colors.push(<span class="hljs-string">&quot;yellow&quot;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Sub();<br><br><br><span class="hljs-built_in">console</span>.log(a.__proto__); <span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;, &quot;yellow&quot;] </span><br><span class="hljs-built_in">console</span>.log(b.__proto__);<span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;, &quot;yellow&quot;] </span><br>a.say(); <span class="hljs-comment">// &#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p>优点：继承了超类原型方法<br>缺点：超类中的引用属性做不到隔离</p><h3 id="组合试继承"><a href="#组合试继承" class="headerlink" title="组合试继承"></a>组合试继承</h3><p>结合经典继承与原型链继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 组合式继承</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>];<br>&#125;<br><br>Super.prototype.say= <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">name,age</span>) </span>&#123;<br>    Super.call(<span class="hljs-built_in">this</span>,name);<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br>Sub.prototype = <span class="hljs-keyword">new</span> Super();<br><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Sub(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">21</span>);<br>a.colors.push(<span class="hljs-string">&quot;yellow&quot;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Sub(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">22</span>);<br><br><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// age: 21</span><br>                 <span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;, &quot;yellow&quot;]</span><br>                  <span class="hljs-comment">// name: &quot;a&quot;</span><br><span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">//age: 22</span><br>                 <span class="hljs-comment">// colors: (3) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;]</span><br>                <span class="hljs-comment">//  name: &quot;b&quot;</span><br>a.say(); <span class="hljs-comment">// ‘a’</span><br></code></pre></td></tr></table></figure><p>优点：隔离超类引用类型属性，复用原型方法<br>缺点：超类构造函数被调用2次</p><h3 id="寄生式"><a href="#寄生式" class="headerlink" title="寄生式"></a>寄生式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 原型链继承</span><br><br><span class="hljs-keyword">var</span> Super = &#123;<br>    name: <span class="hljs-string">&#x27;12&#x27;</span>,<br>    colors:[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">obj</span>) </span>&#123;<br><br><span class="hljs-comment">// 等价于 var f = function()&#123;&#125;; f.prototype = obj; var o = new f();</span><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Object</span>.create(obj); <br>    <span class="hljs-comment">// 增强对象，增加属性方法</span><br>    <br>    <span class="hljs-comment">// new 对象的本质</span><br>    <br>   <span class="hljs-comment">// 1.new 一个新对象</span><br>   <span class="hljs-comment">// 2.obj.__proto__ = 构造函数.原型 </span><br>   <span class="hljs-comment">// 3.执行构造函数，call(this,arguments);</span><br>   <span class="hljs-comment">// 4.返回这个对象</span><br>    <br>    <br>    <span class="hljs-comment">// 通过new 方法，默认返回this 指向Sub的原型，这里强制覆盖</span><br>    <span class="hljs-keyword">return</span> a<br>&#125;<br><br><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Sub(Super);<br>a.colors.push(<span class="hljs-string">&quot;yellow&quot;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Sub(Super);<br><br><span class="hljs-built_in">console</span>.log(a.__proto__); <span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;, &quot;yellow&quot;] </span><br><span class="hljs-built_in">console</span>.log(b.__proto__);<span class="hljs-comment">//  colors: (4) [&quot;red&quot;, &quot;green&quot;, &quot;white&quot;, &quot;yellow&quot;] </span><br></code></pre></td></tr></table></figure><h3 id="寄生组合式"><a href="#寄生组合式" class="headerlink" title="寄生组合式"></a>寄生组合式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 寄生组合式继承</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Super</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>];<br>&#125;<br><br>Super.prototype.say= <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">name,age</span>) </span>&#123;<br>    Super.call(<span class="hljs-built_in">this</span>,name);<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">Sub, Super</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> proto = <span class="hljs-built_in">Object</span>.create(Super.prototype); <span class="hljs-comment">// Super 的一个实例</span><br>    proto.constructor = Sub; <span class="hljs-comment">// 增强对象，复写子类原型会导致constructor 指向丢失</span><br>    Sub.prototype = proto; <span class="hljs-comment">// 原型链继承</span><br>&#125;<br><br>inheritPrototype(Sub, Super);<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Sub(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">21</span>);<br>a.colors.push(<span class="hljs-string">&quot;yellow&quot;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Sub(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">22</span>);<br><br><br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-built_in">console</span>.log(b);<br>a.say();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>chromev8</title>
    <link href="/2020/08/08/chromev8/"/>
    <url>/2020/08/08/chromev8/</url>
    
    <content type="html"><![CDATA[<h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>编译型语言在程序执行之前需要先经过编译，将其编译为机器可以理解的二进制文件，c/c++ go<br>编译过程：</p><p>源代码——&gt;词法分析、语法分析-&gt;AST-&gt;生成中间代码-&gt;代码优化-&gt;二进制文件-&gt;执行</p><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>解释型语言需要每次在运行时都对程序进行动态解释再执行</p><p>编译过程：</p><p>源代码——&gt;词法分析、语法分析-&gt;AST-&gt;字节码-&gt;解释执行-&gt;执行</p><h3 id="v8-如何执行一段代码"><a href="#v8-如何执行一段代码" class="headerlink" title="v8 如何执行一段代码"></a>v8 如何执行一段代码</h3><p><img src="/images/v8.png" alt=""></p><p>1.生成抽象语法树和执行上下文<br>AST 是一种结构，生成它的步骤：分词（tokenize)，将代码分成最小单元；解析，语法分析，将token 数据转成AST</p><p>2.生成字节码</p><p>一开始v8没有字节码，直接将AST装成机器码，执行效率非常高，但是占用内存大，低端机器扛不住。<br>为了解决内存问题，引入了字节码。</p><p>字节码：介于AST 和 机器之前的一种代码，需要被解释器转成机器码了才能执行</p><p>机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用</p><p>3.执行阶段</p><p>通常，第一次执行的字节码，解释器lgnition和逐条解释。在执行的字节码的过程中，<br>如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率</p><h3 id="即时编译-JIT"><a href="#即时编译-JIT" class="headerlink" title="即时编译 JIT"></a>即时编译 JIT</h3><p>字节码 与 解释器、编译器相结合；<br>v8中的解释： 代码每次执行的时候都会进行编译，编译为字节码的时候，解释器需要进行逐条解释，但是如果这段代码被标记为了热点代码，编译器就将它直接编译为了机器代码并保存在内存中，<br>下次会直接使用内存中的机器码，而不需要逐条解释为机器码</p><h3 id="js性能优化"><a href="#js性能优化" class="headerlink" title="js性能优化"></a>js性能优化</h3><p>代码层面的优化，v8已经做到极致了，我们要将重心放在单次脚本的运行时间和网络下载上</p><p>1.单次脚本的执行时间<br>2.避免过大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；<br>3.减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>garbageCollection</title>
    <link href="/2020/07/27/garbageCollection/"/>
    <url>/2020/07/27/garbageCollection/</url>
    
    <content type="html"><![CDATA[<h3 id="栈中垃圾回收"><a href="#栈中垃圾回收" class="headerlink" title="栈中垃圾回收"></a>栈中垃圾回收</h3><p>记录当前执行上下文状态的指针称为ESP</p><p>JavaScript引擎通过向下移动ESP来销毁该函数保存在栈中的执行上下文</p><h3 id="堆内存中的垃圾回收"><a href="#堆内存中的垃圾回收" class="headerlink" title="堆内存中的垃圾回收"></a>堆内存中的垃圾回收</h3><p>代际假说：（The Generational Hypothesis）<br>1.大部分对象在内存中的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；<br>2.不死的对象，活的更久</p><p>v8引擎会把堆分成新生代和老生代两个区域，新生代放置生存时间短的（大小通常为8M)，老生代放置存活时间长的对象<br>（容量一般大于8M)</p><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p>1.副垃圾回收器，只要负责新生代的垃圾回收<br>副垃圾回收器中的对象通常是较小的对象，区域不大，但是回收频繁。<br>新生代中使用Scavenge算法，将新生代的区域分为2半，一半为对象区域，一半为空闲区域<br>新的对象会被加入到对象区域，当对象区域快写满时，就要进行一次垃圾回收。<br>对象区域中的垃圾进行标记-&gt; 副垃圾回收器将活动对象复制到空闲区域,同时会将对象有序的排序（不会产生内存碎片的原因)<br>-&gt;将对象区域与空闲区域的角色进行翻转</p><p>2.主垃圾回收器，主要负责老生代的垃圾回收<br>新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。<br>主垃圾回收器采用的是标记-清楚算法（ Mark-Sweep ）<br>从根元素开始，递归根元素(不能到达的元素，标记为垃圾)-&gt;直接对垃圾数据进行回收<br>标记 - 整理（ Mark-Compact ）<br>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p><h4 id="回收器的工作流程"><a href="#回收器的工作流程" class="headerlink" title="回收器的工作流程"></a>回收器的工作流程</h4><p>1.标记空间中的活动对象与非活动对象，活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象<br>2.回收非活动对象所占据的内存。。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。<br>3.内存整理。垃圾回收之后，内存中会存在大量不连续的内存空间称为内存碎片（不是所有的回收器都会产生内存碎片，例如副垃圾回收器)</p><h4 id="对象晋升策略"><a href="#对象晋升策略" class="headerlink" title="对象晋升策略"></a>对象晋升策略</h4><p>当一个对象经历过2次垃圾回收依然存在，会被移动到老生代中</p><h4 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h4><p>由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）</p><p>为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>store of data</title>
    <link href="/2020/07/23/memory/"/>
    <url>/2020/07/23/memory/</url>
    
    <content type="html"><![CDATA[<h3 id="栈内存与堆内存如何存储数据"><a href="#栈内存与堆内存如何存储数据" class="headerlink" title="栈内存与堆内存如何存储数据"></a>栈内存与堆内存如何存储数据</h3><p>值类型的数据通常保存在栈中，栈空间用来保存执行上下文<br>引用类型的数据通常保存在堆中，并且在栈中留下引用</p><p>栈空间需要用来维护程序执行期间执行上下文的状态，为了提高执行上下文的切换效率，栈的空间一定要相对来说较小</p><h3 id="闭包的内存模型"><a href="#闭包的内存模型" class="headerlink" title="闭包的内存模型"></a>闭包的内存模型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>    <span class="hljs-keyword">let</span> test1 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> test2 = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> innerBar = &#123; <br>        setName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newName</span>)</span>&#123;<br>            myName = newName<br>        &#125;,<br>        getName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(test1)<br>            <span class="hljs-keyword">return</span> myName<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> innerBar<br>&#125;<br><span class="hljs-keyword">var</span> bar = foo()<br>bar.setName(<span class="hljs-string">&quot; 极客邦 &quot;</span>)<br>bar.getName()<br><span class="hljs-built_in">console</span>.log(bar.getName())<br></code></pre></td></tr></table></figure><p>1.首先会创建一个全局执行上下文<br>2.执行到foo函数时，会先进行编译，创建foo函数的执行上下文<br>3.遇到内部函数时，还要对内部函数做一个快速的词法扫描，内部函数引用了外部变量，在堆内存中创建一个closure闭包对象，这个对象会同时包含值与引用2种数据<br>4.这个closure对象保存在变量环境中，由于闭包的特殊性，即使函数执行完毕了，但是返回的对象中的函数依然保留了它的引用</p><p>产生闭包的核心：<br>第一步是需要预扫描内部函数；<br>第二步是把内部函数引用的外部变量保存到堆中</p><p>执行上下文的销毁过程：<br>关于foo函数执行上下文销毁过程：foo函数执行结束之后，当前执行状态的指针下移到栈中的全局执行上下文的位置，foo函数的执行上下文的那块数据就挪出来，这也就是foo函数执行上下文的销毁过程，这个文中有提到，你可以参考“调用栈中切换执行上下文状态“图。</p><p>第二个问题：innerBar返回后，含有setName和getName对象，这两个对象里面包含了堆中的closure(foo)的引用。虽然foo执行上下文销毁了，foo函数中的对closure(foo)的引用也断开了，但是setName和getName里面又重新建立起来了对closure(foo)引用</p><h3 id="执行上下文如何切换"><a href="#执行上下文如何切换" class="headerlink" title="执行上下文如何切换"></a>执行上下文如何切换</h3><p>只需要将指针下移到上个执行上下文的地址就可以了，当前执行上下文栈区空间全部回收，堆中的数据依然保留</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>understand  this &amp; scope chain</title>
    <link href="/2020/07/22/this/"/>
    <url>/2020/07/22/this/</url>
    
    <content type="html"><![CDATA[<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>执行上下文中除了变量环境、词法环境、outer还有this，this是和执行上下文绑定的<br>在对象内部方法中使用对象内部的属性。作用域链与this是2个独立的不同的系统</p><h3 id="判断要数"><a href="#判断要数" class="headerlink" title="判断要数"></a>判断要数</h3><p>this 的绑定和函数声明的位置无关，只取决于函数的调用方式,看它真实的调用的对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>    bar(); <span class="hljs-comment">// ReferenceError 这里是全局作用域 this指向window</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br>foo();<br><br></code></pre></td></tr></table></figure><p>变量的查找与this无关，这里bar函数中的a，查找过程是通过作用域链查找的，向上只能到全局作用域</p><h3 id="this的绑定"><a href="#this的绑定" class="headerlink" title="this的绑定"></a>this的绑定</h3><p>1.默认绑定<br>独立的函数调用，无法调用其他规则时的默认规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a); <span class="hljs-comment">// 2</span><br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>foo();<br><br>这里的foo没有任何修饰符，使用了默认绑定，<span class="hljs-built_in">this</span>指向全局<span class="hljs-built_in">window</span><br>但是如果是严格模式，<span class="hljs-built_in">this</span>并不指向<span class="hljs-built_in">window</span>，而是<span class="hljs-literal">undefined</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a); <span class="hljs-comment">// TypeError this is undefined</span><br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>foo();<br><br></code></pre></td></tr></table></figure><p>注意第三方库的strict应用范围,foo在非严格模式 this会绑定到全局，调用foo不影响默认绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a); <span class="hljs-comment">// 2</span><br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span><br>    foo();<br>&#125;)();<br></code></pre></td></tr></table></figure><p>2.隐式绑定<br>当函数引用有上下文对象时，隐式绑定规则会将this绑定到这个上下文对象上，对象属性引用链只有上一层或者说最后一层起作用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj2 = &#123;<br>    a: <span class="hljs-number">42</span>,<br>    foo: foo<br>&#125;<br><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    a:<span class="hljs-number">2</span>,<br>    obj2:obj1<br>&#125;<br><br>obj1.obj2.foo(); <span class="hljs-comment">// 42</span><br><br></code></pre></td></tr></table></figure><p>隐式丢失，传入回调函数时常发生</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> bar = &#123;<br>    a : <span class="hljs-number">1</span>,<br>    foo: foo<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doFoo</span>(<span class="hljs-params">fn</span>)</span>&#123;<br>    fn();<br>&#125;<br><br><br>doFoo(bar.foo); <span class="hljs-comment">//2</span><br><br></code></pre></td></tr></table></figure><p>bar.foo 实际上指向的是foo函数本身， 函数传参其实一种隐式赋值，这里doFoo使用了默认绑定规则，this指向了widow</p><p>3.显示绑定</p><p>使用call apply显示的将函数的this绑定到某一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    a: <span class="hljs-number">2</span><br>&#125;<br><br>foo.call(obj);<span class="hljs-comment">//2</span><br><br>如果传入了一个原始值、字符创、布尔、数值 来作为<span class="hljs-built_in">this</span>的绑定对象，会先进行装箱<br></code></pre></td></tr></table></figure><p>硬绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>&#125;<br><br><br><span class="hljs-keyword">var</span> bar = &#123;<br>    a : <span class="hljs-number">1</span>,<br>    foo: foo<br>&#125;<br><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//setTimeout(bar.foo);// 会产生绑定隐式丢失</span><br><br><br><span class="hljs-comment">//创建一个baz将foo的this强制绑定到bar</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params"></span>)</span>&#123;<br>    foo.call(bar);<br>&#125;<br><br><span class="hljs-comment">//同 Function.prototype.bind</span><br><br><span class="hljs-built_in">setTimeout</span>(baz);<span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p>4.new 绑定<br>  调用new 发生什么？</p><p>  1.创建一个新对象<br>  2.执行[[Prototype]]链接<br>  3.将新对象绑定到函数调用的this<br>  4.如果没有其它返回则返回这个新对象</p><p>  var obj = {};<br>  obj.<strong>proto</strong> = foo.prototype;<br>  foo.call(obj);<br>  return obj;</p><p>  调用new 时， this绑定到新创建的对象上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.a = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> foo();<span class="hljs-comment">// this-&gt;bar</span><br>bar.a;<span class="hljs-comment">//2</span><br><br></code></pre></td></tr></table></figure><p>优先级：</p><p>默认绑定优先级最低。</p><p>显示绑定与隐式绑定：显示绑定优于隐式绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>&#125;<br><br><span class="hljs-keyword">var</span> bar = &#123;<br>    a:<span class="hljs-number">1</span>,<br>    foo:foo<br>&#125;<br><br><span class="hljs-keyword">var</span> baz = &#123;<br>    a:<span class="hljs-number">2</span>,<br>    foo:foo<br>&#125;<br><br><span class="hljs-comment">//隐式</span><br>bar.foo(); <span class="hljs-comment">// 1</span><br>baz.foo(); <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// 显示</span><br><br>bar.foo.call(baz); <span class="hljs-comment">// 2</span><br>baz.foo.call(bar); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>隐式与new 绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">s</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.a = s;<br>&#125;<br><br><span class="hljs-keyword">var</span> bar = &#123;<br>    foo:foo<br>&#125;<br><br>bar.foo(<span class="hljs-number">2</span>);<br>bar.a;<span class="hljs-comment">//2</span><br><br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> bar.foo(<span class="hljs-number">4</span>);<br>baz.a;<span class="hljs-comment">//4</span><br></code></pre></td></tr></table></figure><p>new –&gt; 显示、硬绑定–&gt; 隐式绑定–&gt;默认绑定</p><p>绑定例外：</p><p>当不关注this指向的时候，可以传入null，此时会使用默认绑定规则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">foo.apply(<span class="hljs-literal">null</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p>安全的this<br>防止this指向全局，我们可以传入一个安全的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ø = <span class="hljs-built_in">Object</span>(<span class="hljs-literal">null</span>);<br>foo.apply(ø,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>箭头函数不受四种规则影响，它根据外层作用域的this决定</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1.当函数作为对象的方法调用时，函数中的 this 就是该对象；<br>2.当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；<br>3.嵌套函数中的 this 不会继承外层函数的 this 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObj = &#123;<br>  name : <span class="hljs-string">&quot; 11 &quot;</span>, <br>  showThis: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)&#125;<br>    bar(); <br>  &#125;<br>&#125;<br>myObj.showThis()<br></code></pre></td></tr></table></figure><p>bar函数中的this被默认绑定到了window上面，它的调用对象可以看做是window<br>解决方法self = this利用闭包构建作用域链；或者箭头函数</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>lexicalspcope &amp; 闭包</title>
    <link href="/2020/07/21/lexicalspcope/"/>
    <url>/2020/07/21/lexicalspcope/</url>
    
    <content type="html"><![CDATA[<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>每个执行上下文中的变量环境中都包含了一个外部应用，用来指向外部引用，我们称之为outer</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(myName)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 111 &quot;</span><br>    bar()<br>&#125;<br><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 22 &quot;</span><br>foo()<br></code></pre></td></tr></table></figure><p>执行到bar的console时，先从bar执行环境中的词法环境中查找变量，没有则从变量环境中查找，仍然没有，<br>通过外部引用查找，这个outer指向了全局执行上下文，获取到myName 22</p><p>词法环境-&gt;变量环境-&gt;外部引用-&gt;全局环境的查找链，就叫做作用域链</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>词法作用域又称静态作用域，因为它是由代码中函数生成的位置决定的，与其它无关，可以预测代码执行过程中如何查找标识符</p><p>词法作用域定义了变量环境中outer 的指向</p><p>bar中外部引用根据词法作用域指向了全局执行上下文而不是foo的执行上下文</p><h3 id="块级作用域中的变量查找"><a href="#块级作用域中的变量查找" class="headerlink" title="块级作用域中的变量查找"></a>块级作用域中的变量查找</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 极客世界 &quot;</span><br>    <span class="hljs-keyword">let</span> test1 = <span class="hljs-number">100</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot;Chrome 浏览器 &quot;</span><br>        <span class="hljs-built_in">console</span>.log(test)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 极客邦 &quot;</span><br>    <span class="hljs-keyword">let</span> test = <span class="hljs-number">2</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> test = <span class="hljs-number">3</span><br>        bar()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br><span class="hljs-keyword">let</span> myAge = <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> test = <span class="hljs-number">1</span><br>foo()<br></code></pre></td></tr></table></figure><p><img src="/images/lexicalscope.png" alt=""></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>词法作用域规定，内部函数总是可以访问外部函数中声明的变量。<br>当调用一个外部函数返回内部函数，即使外部函数已经执行完了，但是内部函数引用外部函数的变量依然<br>保存在内存中，这些变量的集合称为闭包，只要应用在，依然可以重新建立联系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>    <span class="hljs-keyword">let</span> test1 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> test2 = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> innerBar = &#123;<br>        getName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(test1)<br>            <span class="hljs-keyword">return</span> myName<br>        &#125;,<br>        setName:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newName</span>)</span>&#123;<br>            myName = newName<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> innerBar<br>&#125;<br><span class="hljs-keyword">var</span> bar = foo()<br>bar.setName(<span class="hljs-string">&quot; 极客邦 &quot;</span>)<br>bar.getName()<br><span class="hljs-built_in">console</span>.log(bar.getName())<br></code></pre></td></tr></table></figure><p>即使foo执行完毕，但是它返回的innerbar 对象包含了foo内部的引用，test1、myName<br>当执行到 bar.setName 方法中的myName = “极客邦”这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文”的顺序来查找 myName 变量，你可以参考下面的调用栈状态图</p><p>首先是setName的执行上下文中查找myName,然后在它的变量环境中通过外部引用找到foo的闭包<br><img src="/images/lexicalscope_2.png" alt=""></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1.变量的查找流程？<br>2.理解词法作用域、作用域链、闭包<br>3.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> bar = &#123;<br>    myName:<span class="hljs-string">&quot;time.geekbang.com&quot;</span>,<br>    printName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(myName)<br>    &#125;    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot; 极客时间 &quot;</span><br>    <span class="hljs-keyword">return</span> bar.printName<br>&#125;<br><span class="hljs-keyword">let</span> myName = <span class="hljs-string">&quot; 极客邦 &quot;</span><br><span class="hljs-keyword">let</span> _printName = foo()<br>_printName()<br>bar.printName()<br></code></pre></td></tr></table></figure><pre><code>function buildLocationTree(nodeList)&#123;    var nodes = [];    var root = &#123;        root: nodes    &#125;    for(var i = 0; i &lt; nodeList.length; i++)&#123;        var ele = nodeList[i];        var deep = ele.id;        if(!deep)&#123;            nodes.push(createNode(ele.id,ele.name, ele.subLocations, pid))        &#125;else &#123;            var target = nodes;            while(pid&gt;0)&#123;                if(!target.subLocations)&#123;                    target.subLocations = [];                &#125;                pid--;                target = target.subLocations            &#125;            target.push(createNode(ele.id,ele.name, ele.subLocations, pid))        &#125;    &#125;    return root;&#125;function createNode (id, name, subLocations, pid)&#123;    return &#123;        id,        name,        subLocations,        pid     &#125;&#125;</code></pre><p>  function sort(arr){<br>    if(arr.length &lt; 2){<br>      return arr<br>    }</p><pre><code>var arrUnit = arr[5000].timestamp;var left = [],    right = [];for(var i = 1; i &lt; arr.length; i++)&#123;  if( arr[i].timestamp &lt; arrUnit)&#123;    left.push(arr[i]);  &#125;else &#123;    right.push(arr[i]);  &#125;&#125;    return sort(left).concat(arrUnit,sort(right))&#125;function matchNum(str)&#123;        return str.match(/uin=\D*(\d+)/)[1];&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>scope</title>
    <link href="/2020/07/20/scope/"/>
    <url>/2020/07/20/scope/</url>
    
    <content type="html"><![CDATA[<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域决定了一段代码能访问到那些数据，这些数据保存在词法环境对象中<br>变量与函数的作用范围，控制着变量与函数的可见性与声明周期</p><p>es6 之前只有全局作用域与函数作用域。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>为了解决变量提升带来的覆盖与污染问题，出现了块级作用域 const、let</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span><br>    &#123;<br>      <span class="hljs-keyword">let</span> b = <span class="hljs-number">3</span><br>      <span class="hljs-keyword">var</span> c = <span class="hljs-number">4</span><br>      <span class="hljs-keyword">let</span> d = <span class="hljs-number">5</span><br>      <span class="hljs-built_in">console</span>.log(a)<br>      <span class="hljs-built_in">console</span>.log(b)<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(b) <br>    <span class="hljs-built_in">console</span>.log(c)<br>    <span class="hljs-built_in">console</span>.log(d)<br>&#125;   <br>foo()<br></code></pre></td></tr></table></figure><p>1.函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。<br>2.通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。<br>3.在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中</p><p>执行这个作用域块的时候，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中<br>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量<br>当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。</p><h3 id="变量提升与块级作用域的提升"><a href="#变量提升与块级作用域的提升" class="headerlink" title="变量提升与块级作用域的提升"></a>变量提升与块级作用域的提升</h3><p>变量环境实现函数级作用域：<br>执行一个函数时，会创建一个执行上下文，其中的变量环境会保存该函数代码内生成的变量</p><p>块级作用域通过词法环境的栈结构实现</p><h3 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h3><p>函数只会在第一次执行的时候被编译，所以编译时变量环境和词法环境最顶层数据已经确定了。</p><p>当执行到块级作用域的时候，块级作用域中通过let和const申明的变量会被追加到词法环境中，当这个块执行结束之后，追加到词法作用域的内容又会销毁掉。</p><p>参考：<br><a href="https://www.jianshu.com/p/0fcc26e13300">https://www.jianshu.com/p/0fcc26e13300</a></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1.函数级作用域如何实现？<br>2.块级作用域又是如何实现的？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>javascript 执行上下文与调用栈</title>
    <link href="/2020/07/16/javascript/"/>
    <url>/2020/07/16/javascript/</url>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>执行上下文：js执行一段代码时的运行环境。</p><p>调用栈：是一种用来管理函数之间调用关系的数据结构。</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>在执行一段代码时，会做一些准备工作，代码先进行编译后执行，编译的时候就会产生可执行代码与执行上下文。<br>词法分析-&gt;语法分析-&gt;代码生成</p><p>创建执行上下文的三种情况：<br>1.执行全局代码时，会生成全局上下文，整个页面的生命周期内，全局上下文唯一<br>2.函数被调用时，函数体内的代码会被编译，创建函数执行上下文，无闭包的话使用完之后就被销毁<br>3.eval被执行时，eval内的代码被编译，创建执行上下文</p><p><img src="/images/stack_2.png" alt=""></p><h3 id="执行上下文包含的属性"><a href="#执行上下文包含的属性" class="headerlink" title="执行上下文包含的属性"></a>执行上下文包含的属性</h3><p>1.变量环境组件： 指定一个词法环境对象，其环境数据用于保存由该执行环境内的代码通过var 与 functionDeclartion创建的绑定<br>2.词法环境组件：指定一个词法环境对象，用于解析该执行环境内的代码创建的标识符引用；<br>3.this ：指定该环境this关键字关联的值</p><p>每个词法环境对象包含2部分：<br>环境记录器<br>外部环境的引用（全局词法环境为空)</p><p>环境记录器<br>环境记录器分为两种：<br>1）声明式环境记录器<br>存在于函数作用域中，存储变量、函数、参数。<br>2）对象式环境记录器<br>存在于全局作用域和块级作用域中，存储变量、函数</p><p>外部环境引用<br>如果在当前环境内找不到变量，引擎可以通过引用在外部环境继续查找</p><p>其中执行环境的词法环境和变量环境组件始终为词法环境对象。当创建一个执行环境时，其词法环境组件和变量环境组件最初是同一个值。在该执行环境相关联的代码的执行过程中，变量环境组件永远不变，而词法环境组件有可能改变</p><p>词法环境中，进入或者退出一个块级作用域，里面的数据都会改变</p><p>区别是：<br>let、const声明的变量，外部环境引用保存在词法环境组件中。<br>var和function声明的变量，外部环境引用保存在环境变量组件中</p><h3 id="如何管理执行上下文？"><a href="#如何管理执行上下文？" class="headerlink" title="如何管理执行上下文？"></a>如何管理执行上下文？</h3><p>创建一个执行上下文栈(Execution context stack, ECS),又称调用栈</p><p>JavaScript引擎使用栈的结构来管理执行上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">b,c</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> b+c<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAll</span>(<span class="hljs-params">b,c</span>)</span>&#123;<br><span class="hljs-keyword">var</span> d = <span class="hljs-number">10</span><br>result = add(b,c)<br><span class="hljs-keyword">return</span>  a+result+d<br>&#125;<br>addAll(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>第一步： 代码编译，创建全局上下文，并将其压入栈底<br><img src="/images/stack_1.png" alt=""></p><p>第二步： 调用addAll函数，编译addAll函数并创建函数执行上下文，将它压入栈中</p><p>第三步： 执行addAll函数，到add函数时，编译add函数并创建执行上下文，压入栈中</p><p>第四部：执行add函数，返回结果，将add函数弹出栈</p><p>第五步：addAll函数中拿到result结果，返回结果，将addAll上下文也弹出</p><p>第六步： 返回结果，执行完毕</p><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>栈的最大容量和深度都是有限制的，超出限制，就会抛出错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Maximum call stack size exceeded<br></code></pre></td></tr></table></figure><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1.什么是执行上下文，它包含了哪些属性？<br>2.变量环境与词法环境的相同点与差异点？</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
